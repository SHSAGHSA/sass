(Menus para el scout: Primary [Slot 0])
Primary [Slot 0]
Scattergun : Index (13) class weapon : (tf_weapon_scattergun)
Scattergun (Renamed/Strange) : Index (200) class_weapon: (tf_weapon_scattergun)
Force-A-Nature : index (45) class weapon : (tf_weapon_scattergun)
The Shortstop : index (220) class weapon : (tf_weapon_handgun_scout_primary)
The Soda Popper : index (448) class weapon : (tf_weapon_soda_popper)
Festive Scattergun : index (669) class weapon : (tf_weapon_scattergun)
Baby Face's Blaster : index (772) class weapon : (tf_weapon_pep_brawler_blaster)
Silver Botkiller Scattergun Mk.I : index (799) class weapon : (tf_weapon_scattergun)
Gold Botkiller Scattergun Mk.I : index (808) class weapon : (tf_weapon_scattergun)
Rust Botkiller Scattergun Mk.I : index (888) class weapon : (tf_weapon_scattergun)
Blood Botkiller Scattergun Mk.I : index (897) class weapon : (tf_weapon_scattergun)
Carbonado Botkiller Scattergun Mk.I : index (906) class weapon : (tf_weapon_scattergun)
Diamond Botkiller Scattergun Mk.I : index (915) class weapon : (tf_weapon_scattergun)
Silver Botkiller Scattergun Mk.II : index (964) class weapon : (tf_weapon_scattergun)
Gold Botkiller Scattergun Mk.II : index (973) class weapon : (tf_weapon_scattergun)
Festive Force-A-Nature : index (1078) class weapon : (tf_weapon_scattergun)
The Back Scatter : index (1103) class weapon : (tf_weapon_scattergun)
Night Terror : index (15002) class weapon : (tf_weapon_scattergun)
Tartan Torpedo : index (15015) class weapon : (tf_weapon_scattergun)
Country Crusher : index (15021) class weapon : (tf_weapon_scattergun)
Backcountry Blaster : index (15029) class weapon : (tf_weapon_scattergun)
Spruce Deuce : index (15036) class weapon : (tf_weapon_scattergun)
Current Event : index (15053) class weapon : (tf_weapon_scattergun)
Macabre Web : index (15065) class weapon : (tf_weapon_scattergun)
Nutcracker : index (15069) class weapon : (tf_weapon_scattergun) 
Blue Mew : index (15106) class weapon : (tf_weapon_scattergun)
Flower Power : index (15107) class weapon : (tf_weapon_scattergun)
Shot to Hell : index (15108) class weapon : (tf_weapon_scattergun)
Coffin Nail : index (15131) class weapon : (tf_weapon_scattergun)
Killer Bee : index (15151) class weapon :  (tf_weapon_scattergun)
Corsair : index (15157) class weapon :  (tf_weapon_scattergun)
(segundo menu para el scout "Secondary [Slot 1]")
Secondary [Slot 1]:
Scout's Pistol : index (23) class weapon : (tf_weapon_pistol)
Pistol (Renamed/Strange) : index (209) class weapon : (tf_weapon_pistol)
Bonk! Atomic Punch : index (46) class weapon : (tf_weapon_lunchbox_drink)
Vintage Lugermorph : index (160) class weapon : (tf_weapon_pistol)
Crit-a-Cola : index (163) class weapon : (tf_weapon_lunchbox_drink)
Mad Milk : index (222) class weapon : (tf_weapon_jar_milk)
Lugermorph : index (294) class weapon : (tf_weapon_pistol)
The Winger : index (449) class weapon : (tf_weapon_handgun_scout_secondary)
Pretty Boy's Pocket Pistol : index (773) class weapon : (tf_weapon_handgun_scout_secondary)
The Flying Guillotine : index (812) class weapon : (tf_weapon_cleaver)
The Flying Guillotine (Genuine) : index (833) class weapon (tf_weapon_cleaver)
Mutated Milk : index (1121) class weapon : (tf_weapon_jar_milk)
Festive Bonk! : index (1145) class weapon : (tf_weapon_lunchbox_drink)
Red Rock Roscoe : index (15013) class weapon : (tf_weapon_pistol)
Homemade Heater : index (15018) class weapon : (tf_weapon_pistol)
Hickory Holepuncher : index (15035) class weapon : (tf_weapon_pistol)
Local Hero : index (15041) class weapon : (tf_weapon_pistol)
Black Dahlia : index (15046) class weapon : (tf_weapon_pistol)
Sandstone Special : index (15056) class weapon : (tf_weapon_pistol)
Macabre Web : index (15060) class weapon : (tf_weapon_pistol)
Nutcracker : index (15069)  class weapon : tf_weapon_pistol
Blue Mew : index (15100) class weapon : tf_weapon_pistol
Brain Candy : index (15101) class weapon : tf_weapon_pistol
Shot to Hell : index (15102) class weapon : tf_weapon_pistol
Dressed To Kill : index (15126) class weapon : tf_weapon_pistol
Blitzkrieg : index (15148) class weapon : tf_weapon_pistol
The C.A.P.P.E.R. : index (30666) class weapon : tf_weapon_pistol

(tercer menu del scout: Melee [Slot 2])
Melee [Slot 2]:
Bat : index (0) class weapon : tf_weapon_bat
Bat (Renamed/Strange) : index (190) class weapon : tf_weapon_bat
The Sandman : index (44) class weapon : tf_weapon_bat_wood 
The Holy Mackerel : index (221) class weapon : tf_weapon_bat_fish
Frying Pan : index (264) class weapon : saxxy 
The Candy Cane : index (317) class weapon : tf_weapon_bat
The Boston Basher : index (325) class weapon : tf_weapon_bat
Sun-on-a-Stick : index (349) class weapon : tf_weapon_bat
The Fan O'War : index (355) class weapon : tf_weapon_bat
Saxxy : index (423) class weapon : saxxy 
The Atomizer : index (450) class weapon : tf_weapon_bat
Three-Rune Blade : index (452) class weapon : tf_weapon_bat 
The Conscientious Objector : index (474) class weapon : saxxy  
Unarmed Combat : index (572) class weapon : tf_weapon_bat_fish
The Wrap Assassin : index (648) class weapon : tf_weapon_bat_giftwrap
Festive Bat : index (660) class weapon : tf_weapon_bat 
The Freedom Staff : index (880) class weapon : saxxy 
The Bat Outta Hell : index (939) class weapon : saxxy 
The Memory Maker : index (954) class weapon : saxxy 
Festive Holy Mackerel : index (999) class weapon : tf_weapon_bat_fish
The Ham Shank : index (1013) class weapon : saxxy 
Gold Frying Pan : index (1071) class weapon : saxxy 
The Necro Smasher : index (1123) class weapon : saxxy 
The Crossing Guard : index (1127) class weapon : saxxy  
Batsaber : index (30667) class weapon : tf_weapon_bat
Prinny Machete : index (30758) class weapon : saxxy 

(ahora menu para soldier: son 3 tambien el primero es: Primary [Slot 0])
Primary [Slot 0] :
Rocket Launcher : index (18) class weapon : tf_weapon_rocketlauncher
Rocket Launcher (Renamed/Strange) : index (205) class weapon : tf_weapon_rocketlauncher
The Direct Hit : index (127) class weapon : tf_weapon_rocketlauncher_directhit
The Black Box : index (228) class weapon : tf_weapon_rocketlauncher
Rocket Jumper : index (237) class weapon : tf_weapon_rocketlauncher
The Liberty Launcher : index (414) class weapon : tf_weapon_rocketlauncher
The Cow Mangler 5000 : index (441) class weapon : tf_weapon_particle_cannon
The Original : index (513) class weapon : tf_weapon_rocketlauncher 
Festive Rocket Launcher : index (658) class weapon : tf_weapon_rocketlauncher
The Beggar's Bazooka : index (730) class weapon : tf_weapon_rocketlauncher 
Silver Botkiller Rocket Launcher Mk.I : index (800) class weapon : tf_weapon_rocketlauncher
Gold Botkiller Rocket Launcher Mk.I : index (809) class weapon : tf_weapon_rocketlauncher
Rust Botkiller Rocket Launcher Mk.I : index (889) class weapon : tf_weapon_rocketlauncher
Blood Botkiller Rocket Launcher Mk.I : index (898) class weapon : tf_weapon_rocketlauncher
Carbonado Botkiller Rocket Launcher Mk.I : index (907) class weapon : tf_weapon_rocketlauncher
Diamond Botkiller Rocket Launcher Mk.I : index (916) class weapon : tf_weapon_rocketlauncher
Silver Botkiller Rocket Launcher Mk.II : index (965) class weapon : tf_weapon_rocketlauncher
Gold Botkiller Rocket Launcher Mk.II : index (974) class weapon : tf_weapon_rocketlauncher
Festive Black Box : index (1085) class weapon : tf_weapon_rocketlauncher 
The Air Strike : index (1104) tf_weapon_rocketlauncher_airstrike
Woodland Warrior : index (15006) class weapon : tf_weapon_rocketlauncher
Sand Cannon : index (15014) class weapon : tf_weapon_rocketlauncher
American Pastoral : index (15028) class weapon : tf_weapon_rocketlauncher
Smalltown Bringdown : index (15043) class weapon : tf_weapon_rocketlauncher
Shell Shocker : index (15052) class weapon : tf_weapon_rocketlauncher
Aqua Marine : index (15057) class weapon : tf_weapon_rocketlauncher
Autumn : index ( 15081) class weapon : tf_weapon_rocketlauncher
Blue Mew : index (15104) class weapon : tf_weapon_rocketlauncher
Brain Candy : index (15105) class weapon : tf_weapon_rocketlauncher
Coffin Nail : index (15129) class weapon : tf_weapon_rocketlauncher
High Roller's : index (15130) class weapon : tf_weapon_rocketlauncher
Warhawk : index (15150) class weapon : tf_weapon_rocketlauncher

(segundo menu del soldier: Secondary [Slot 1])
Secondary [Slot 1]:
Soldier's Shotgun : index (10) class weapon : tf_weapon_shotgun_soldier
Shotgun (Renamed/Strange) : index (199) class weapon : tf_weapon_shotgun
The Buff Banner : index (129) class weapon : tf_weapon_buff_item
Gunboats : index (133) class weapon : tf_wearable
The Battalion's Backup : index (226) class weapon : tf_weapon_buff_item
The Concheror : index (354) class weapon : tf_weapon_buff_item
The Reserve Shooter : indec (415) class weapon : tf_weapon_shotgun
The Righteous Bison : index (442) class weapon : tf_weapon_raygun
The Mantreads : index (444) class weapon : tf_wearable
Festive Buff Banner : index (1001) class weapon : tf_weapon_buff_item
The B.A.S.E. Jumper : index (1101) class weapon : tf_weapon_parachute
Festive Shotgun : index (1141) class weapon : tf_weapon_shotgun
Panic Attack : index (1153) class weapon : tf_weapon_shotgun
Backwoods Boomstick : index (15003) class weapon : tf_weapon_shotgun
Rustic Ruiner : index (15016) class weapon : tf_weapon_shotgun
Civic Duty : index (15044) class weapon : tf_weapon_shotgun
Lightning Rod : index (15047) class weapon : tf_weapon_shotgun
Autumn : index (15085) class weapon : tf_weapon_shotgun
Flower Power : index (15109) class weapon : tf_weapon_shotgun
Coffin Nail : index (15132) class weapon : tf_weapon_shotgun
Dressed to Kill : index (15133) class weapon : tf_weapon_shotgun
Red Bear : index (15152) class weapon : tf_weapon_shotgun

(tercer menu del soldier: Secondary [Slot 1])
Shovel : index (6) class weapon : tf_weapon_shovel
Shovel (Renamed/Strange) : index (196) class weapon : tf_weapon_shovel
The Equalizer : index (128) class weapon : tf_weapon_shovel
The Pain Train : index (154) class weapon : tf_weapon_shovel
Frying Pan : index (264) class weapon : tf_weapon_shovel
The Half-Zatoichi : index (357) class weapon : tf_weapon_katana
The Market Gardener : index (416) class weapon : tf_weapon_shovel
Saxxy : index (423) class weapon : saxxy 
The Disciplinary Action : index (447) class weapon : tf_weapon_shovel
The Conscientious Objector : index (474) class weapon : saxxy
The Escape Plan : index (775) class weapon : tf_weapon_shovel
The Freedom Staff : index (880) class weapon : saxxy
The Bat Outta Hell : index (939) class weapon : saxxy
The Memory Maker : index (954) class weapon : saxxy
The Ham Shank : index (1013) class weapon : saxxy
Gold Frying Pan : index (1071) class weapon : saxxy
The Necro Smasher : index (1123) class weapon : saxxy
The Crossing Guard : index (1127) class weapon : saxxy
Prinny Machete : index (30758) class weapon : saxxy

(ahora los menus para el pyro, el primero es Primary [Slot 0])
Primary [Slot 0]: 
Flame Thrower : index (21) class weapon : tf_weapon_flamethrower
Flame Thrower (Renamed/Strange) : index (208) class weapon : tf_weapon_flamethrower
The Backburner : index (40) class weapon : tf_weapon_flamethrower
The Degreaser : index (215) class weapon : tf_weapon_flamethrower
The Phlogistinator : index (594) class weapon : tf_weapon_flamethrower
Festive Flame Thrower : index (659) class weapon : tf_weapon_flamethrower
The Rainblower : index (741) class weapon : tf_weapon_flamethrower
Silver Botkiller Flame Thrower Mk.I : index (798) class weapon : tf_weapon_flamethrower
Gold Botkiller Flame Thrower Mk.I : index (807) class weapon : tf_weapon_flamethrower
Rust Botkiller Flame Thrower Mk.I : index (887) class weapon : tf_weapon_flamethrower
Blood Botkiller Flame Thrower Mk.I : index (896) class weapon : tf_weapon_flamethrower
Carbonado Botkiller Flame Thrower Mk.I : index (905) class weapon : tf_weapon_flamethrower
Diamond Botkiller Flame Thrower Mk.I : index (914) class weapon : tf_weapon_flamethrower
Silver Botkiller Flame Thrower Mk.II : index (963) class weapon : tf_weapon_flamethrower
Gold Botkiller Flame Thrower Mk.II : index (972) class weapon : tf_weapon_flamethrower
Festive Backburner : index (1146) class weapon : tf_weapon_flamethrower
Dragon's Fury : index (1178) class weapon : tf_weapon_rocketlauncher_fireball
Forest Fire : index (15005) class weapon : tf_weapon_flamethrower
Barn Burner : index (15017) class weapon : tf_weapon_flamethrower
Bovine Blazemaker : index (15030) class weapon : tf_weapon_flamethrower
Earth, Sky and Fire : index (15034) class weapon : tf_weapon_flamethrower
Flash Fryer : index (15049) class weapon : tf_weapon_flamethrower
Turbine Torcher : index (15054) class weapon : tf_weapon_flamethrower
Autumn : index (15066) class weapon : tf_weapon_flamethrower
Pumpkin Patch : index (15067) class weapon : tf_weapon_flamethrower
Nutcracker : index (15068) class weapon : tf_weapon_flamethrower
Balloonicorn : index (15089) class weapon : tf_weapon_flamethrower
Rainbow : index (15090) class weapon : tf_weapon_flamethrower
Coffin Nail : index (15115) class weapon : tf_weapon_flamethrower
Warhawk : index (15141) class weapon : tf_weapon_flamethrower
Nostromo Napalmer : index (30474) class weapon : tf_weapon_flamethrower

(ahora el segundo menu del pyro, es este: Secondary [Slot 1])
Secondary [Slot 1]:
Pyro's Shotgun : index (12) class weapon : tf_weapon_shotgun_pyro
Shotgun (Renamed/Strange) : index (199) class weapon : tf_weapon_shotgun
The Flare Gun : index (39) class weapon : tf_weapon_flaregun
The Detonator : index (351) class weapon : tf_weapon_flaregun
The Reserve Shooter : index (415) class weapon : tf_weapon_shotgun
The Manmelter : index (595) class weapon : tf_weapon_flaregun_revenge
The Scorch Shot : index (740) class weapon : tf_weapon_flaregun
Festive flare Gun : index (1081) class weapon : tf_weapon_flaregun
Festive Shotgun : index (1141) class weapon : tf_weapon_shotgun
Panic Attack : index (1153) class weapon : tf_weapon_shotgun
Thermal Thruster : index (1179) class weapon : tf_weapon_rocketpack
Gas Passer : index (1180) class weapon : tf_weapon_jar_gas
Backwoods Boomstick : index (15003) class weapon : tf_weapon_shotgun
Rustic Ruiner : index (15016) class weapon : tf_weapon_shotgun
Civic Duty : index (15044) class weapon : tf_weapon_shotgun
Lightning Rod : index (15047) class weapon : tf_weapon_shotgun
Autumn : index (15085) class weapon : tf_weapon_shotgun
Flower Power : index (15109) class weapon : tf_weapon_shotgun
Coffin Nail : index (15132) class weapon : tf_weapon_shotgun
Dressed to Kill : index (15133) class weapon : tf_weapon_shotgun
Red Bear : index (15152) class weapon : tf_weapon_shotgun

(ahora el tercer menu del pyro, Melee [Slot 2])
Melee [Slot 2] : 
Fire Axe : index (2) class weapon : tf_weapon_fireaxe
Fire Axe (Renamed/Strange) : index (192) class weapon : tf_weapon_fireaxe
The Axtinguisher : index (38) class weapon : tf_weapon_fireaxe
Homewrecker : index (153) class weapon : tf_weapon_fireaxe
The Powerjack : index (214) class weapon : tf_weapon_fireaxe
Frying Pan : index (264) class weapon : saxxy
The Back Scratcher : index (326) class weapon : tf_weapon_fireaxe
Sharpened Volcano Fragment : index (348) class weapon : tf_weapon_fireaxe
Saxxy : index (423) class weapon : saxxy
The Postal Pummeler : index (457) class weapon : tf_weapon_fireaxe
The Maul : index (466) class weapon : tf_weapon_fireaxe
The Conscientious Objector : index (474) class weapon : saxxy
The Third Degree : index (593) class weapon : tf_weapon_fireaxe
The Lollichop : index (739) class weapon : tf_weapon_fireaxe
Neon Annihilator : index (813) class weapon : tf_weapon_breakable_sign
Neon Annihilator (Genuine) : index (834) class weapon : tf_weapon_breakable_sign
The Freedom Staff : index (880) class weapon : saxxy
The Bat Outta Hell : index (939) class weapon : saxxy
The Memory Maker : index (954) class weapon : saxxy
The Festive Axtinguisher : index (1000) class weapon : tf_weapon_fireaxe
The Ham Shank : index (1013)  class weapon : saxxy
Gold Frying Pan : index (1071) class weapon : saxxy
The Necro Smasher : index (1123) class weapon : saxxy
The Crossing Guard : index (1127) class weapon : saxxy
Hot Hand : index (1181) class weapon : tf_weapon_slap
Prinny Machete : index (30758) class weapon : saxxy

(ahora los menus para el demoman, primero: Primary [Slot 0])
Primary [Slot 0] :
Grenade Launcher : index (19) class weapon : tf_weapon_grenadelauncher
Grenade Launcher (Renamed/Strange) : index (206) class weapon : tf_weapon_grenadelauncher
The Loch-n-Load : index (308) class weapon : tf_weapon_grenadelauncher
Ali Baba's Wee Booties : index (405) class weapon : tf_wearable
The Bootlegger : index (608) class weapon : tf_wearable
The Loose Cannon : index (996) class weapon : 	tf_weapon_cannon
Festive Grenade Launcher : index (1007) class weapon : tf_weapon_grenadelauncher
The B.A.S.E. Jumper : index (1101) class weapon : tf_weapon_parachute
The Iron Bomber : index (1151) class weapon : tf_weapon_grenadelauncher
Autumn : index (15077) class weapon : tf_weapon_grenadelauncher
Macabre Web : index (15079) class weapon : tf_weapon_grenadelauncher
Rainbow : index (15091) class weapon : tf_weapon_grenadelauncher
Sweet Dreams : index (15092) class weapon : tf_weapon_grenadelauncher
Coffin Nail : index (15116) class weapon : tf_weapon_grenadelauncher
Top Shelf : index (15117) class weapon : tf_weapon_grenadelauncher
Warhawk : index (15142) class weapon : tf_weapon_grenadelauncher
Butcher Bird : index (15158) class weapon : tf_weapon_grenadelauncher

(segundo menu del demoman, Secondary [Slot 1])
Secondary [Slot 1]:
Stickybomb Launcher : index (20) class weapon : tf_weapon_pipebomblauncher
Stickybomb Launcher (Renamed/Strange) : index (207) class weapon : tf_weapon_pipebomblauncher
The Scottish Resistance : index (130) class weapon : tf_weapon_pipebomblauncher 
The Chargin' Targe : index (131) class weapon : tf_wearable_demoshield
Sticky Jumper : index (265) class weapon : tf_weapon_pipebomblauncher
The Splendid Screen : index (406) class weapon : tf_wearable_demoshield
Festive Stickybomb Launcher : index (661)  class weapon : tf_weapon_pipebomblauncher
Silver Botkiller Stickybomb Launcher Mk.I : index (797) class weapon : tf_weapon_pipebomblauncher
Gold Botkiller Stickybomb Launcher Mk.I : index (806) class weapon : tf_weapon_pipebomblauncher
Rust Botkiller Stickybomb Launcher Mk.I : index (887) class weapon : tf_weapon_pipebomblauncher
Blood Botkiller Stickybomb Launcher Mk.I : index (895) class weapon : tf_weapon_pipebomblauncher
Carbonado Botkiller Stickybomb Launcher Mk.I : index (904) class weapon : tf_weapon_pipebomblauncher
Diamond Botkiller Stickybomb Launcher Mk.I : index (913) class weapon : tf_weapon_pipebomblauncher
Silver Botkiller Stickybomb Launcher Mk.II : index (962) class weapon : tf_weapon_pipebomblauncher
Gold Botkiller Stickybomb Launcher Mk.II : index (971) class weapon : tf_weapon_pipebomblauncher
The Tide Turner : index (1099) class weapon : tf_wearable_demoshield
Festive Targe : index (1144) class weapon : tf_wearable_demoshield
The Quickiebomb Launcher : index (1150) class weapon : tf_weapon_pipebomblauncher
Sudden Flurry : index (15009) class weapon : tf_weapon_pipebomblauncher
Carpet Bomber : index (15012) class weapon : tf_weapon_pipebomblauncher
Blasted Bombardier : index (15024) class weapon : tf_weapon_pipebomblauncher
Rooftop Wrangler : index (15038) class weapon : tf_weapon_pipebomblauncher
Liquid Asset : index (15043) class weapon : tf_weapon_pipebomblauncher
Pink Elephant : index (15048) class weapon : tf_weapon_pipebomblauncher
Autumn : index (15082) class weapon : tf_weapon_pipebomblauncher
Pumpkin Patch : index (15083) class weapon : tf_weapon_pipebomblauncher
Macabre Web : index (15084) class weapon : tf_weapon_pipebomblauncher
Sweet Dreams : index (15137) class weapon : tf_weapon_pipebomblauncher
Coffin Nail : index (15153) class weapon : tf_weapon_pipebomblauncher
Dressed to Kill : index (15154) class weapon : tf_weapon_pipebomblauncher
Blitzkrieg : index (15155) class weapon : tf_weapon_pipebomblauncher

(ahora el tercer menu del demoman, Melee [Slot 2])
Melee [Slot 2] :
Bottle : index (1) class weapon : tf_weapon_bottle
Bottle (Renamed/Strange) : index (191) class weapon : tf_weapon_bottle
The Eyelander : index (132) class weapon : tf_weapon_sword
The Pain Train : index (154) class weapon : tf_weapon_shovel
The Scotsman's Skullcutter : index (172) class weapon : tf_weapon_sword
Frying Pan : index (264) class weapon : saxxy
Horseless Headless Horsemann's Headtaker : index (266) class weapon : tf_weapon_sword
Ullapool Caber : index (307) class weapon : tf_weapon_stickbomb
The Claidheamh Mòr : index (327) class weapon : tf_weapon_sword
The Half-Zatoichi : index (357) class weapon : tf_weapon_katana
The Persian Persuader : index (404) class weapon : tf_weapon_sword
Saxxy : index (423) class weapon : saxxy
The Conscientious Objector : index (474) class weapon : saxxy
Nessie's Nine Iron : index (482) class weapon : tf_weapon_sword
The Scottish Handshake : index (609) class weapon : tf_weapon_bottle
The Freedom Staff : index (880) class weapon : saxxy
The Bat Outta Hell : index (939) class weapon : saxxy
The Memory Maker : index (954) class weapon : saxxy
The Ham Shank : index (1013) class weapon : saxxy
Gold Frying Pan : index (1071) class weapon : saxxy
Festive Eyelander : index (1082) class weapon : tf_weapon_sword
The Necro Smasher : index (1123) class weapon : saxxy
The Crossing Guard : index (1127) class weapon : saxxy
Prinny Machete : index (30758) class weapon : saxxy

(ahora los menus del heavy, Primary [Slot 0])
Primary [Slot 0] :
Minigun : index (15) class weapon : tf_weapon_minigun
Minigun (Renamed/Strange) : index (202) class weapon : tf_weapon_minigun
Natascha : index (41) class weapon : tf_weapon_minigun
Iron Curtain : index (298) class weapon : tf_weapon_minigun
The Brass Beast : index (312) class weapon : tf_weapon_minigun
Tomislav : index (424) class weapon : tf_weapon_minigun
Festive Minigun : index (654) class weapon : tf_weapon_minigun
Silver Botkiller Minigun Mk.I : index (793) class weapon : tf_weapon_minigun
Gold Botkiller Minigun Mk.I : index (802) class weapon : tf_weapon_minigun
The Huo-Long Heater : index (811) class weapon : tf_weapon_minigun
The Huo-Long Heater (Genuine) : index (832) class weapon : tf_weapon_minigun
Deflector (MvM only?) : index (850) class weapon : tf_weapon_minigun
Rust Botkiller Minigun Mk.I : index (882) class weapon : tf_weapon_minigun
Blood Botkiller Minigun Mk.I : index (891) class weapon : tf_weapon_minigun
Carbonado Botkiller Minigun Mk.I : index (900) class weapon : tf_weapon_minigun
Diamond Botkiller Minigun Mk.I : index (909) class weapon : tf_weapon_minigun
Silver Botkiller Minigun Mk.II : index (958) class weapon : tf_weapon_minigun
Gold Botkiller Minigun Mk.II : index (967) class weapon : tf_weapon_minigun
King of the Jungle : index (15004) class weapon : tf_weapon_minigun
Iron Wood : index (15020) class weapon : tf_weapon_minigun
Antique Annihilator : index (15025) class weapon : tf_weapon_minigun
War Room : index (15031) class weapon : tf_weapon_minigun
Citizen Pain : index (15040) class weapon : tf_weapon_minigun
Brick House : index (15051) class weapon : tf_weapon_minigun
Macabre Web : index (15086) class weapon : tf_weapon_minigun
Pumpkin Patch : index (15087) class weapon : tf_weapon_minigun
Nutcracker : index (15088) class weapon : tf_weapon_minigun
Brain Candy : index (15098) class weapon : tf_weapon_minigun
Mister Cuddles : index (15099) class weapon : tf_weapon_minigun
Coffin Nail : index (15123) class weapon : tf_weapon_minigun
Dressed to Kill : index (15124) class weapon : tf_weapon_minigun
Top Shelf : index (15135) class weapon : tf_weapon_minigun
Butcher Bird : index (15147) class weapon : tf_weapon_minigun

(segundo menu del heavy, Secondary [Slot 1])
Secondary [Slot 1]:
Heavy's Shotgun : index (11) class weapon : tf_weapon_shotgun_hwg
Shotgun (Renamed/Strange) : index (199) class weapon : tf_weapon_shotgun
Sandvich : index (42) class weapon : tf_weapon_lunchbox
The Dalokohs Bar : index (159) class weapon : tf_weapon_lunchbox
The Buffalo Steak Sandvich : index (311) class weapon : tf_weapon_lunchbox
The Family Business : index (425) class weapon : tf_weapon_shotgun_hwg
Fishcake : index (433) class weapon : tf_weapon_lunchbox
Robo-Sandvich : index (863) class weapon : tf_weapon_lunchbox
Festive Sandvich : index (1002) class weapon : tf_weapon_lunchbox
Festive Shotgun : index (1141) class weapon : tf_weapon_shotgun
Panic Attack : index (1153) class weapon : tf_weapon_shotgun
Second Banana : index (1190) class weapon : tf_weapon_lunchbox
Backwoods Boomstick : index (15003) class weapon : tf_weapon_shotgun
Rustic Ruiner : index (15016) class weapon : tf_weapon_shotgun
Civic Duty : index (15044) class weapon : tf_weapon_shotgun
Lightning Rod : index (15047) class weapon : tf_weapon_shotgun
Autumn : index (15085) class weapon : tf_weapon_shotgun
Flower Power : index (15109) class weapon : tf_weapon_shotgun
Coffin Nail : index (15132) class weapon : tf_weapon_shotgun
Dressed to Kill : index (15133) class weapon : tf_weapon_shotgun
Red Bear : index (15152) class weapon : tf_weapon_shotgun

(tercer menu del heavy, Melee [Slot 2])
Melee [Slot 2]:
Fists : index (5) class weapon : tf_weapon_fists
Fists (Renamed/Strange) : index (195) class weapon : tf_weapon_fists
The Killing Gloves of Boxing : index (43) class weapon : tf_weapon_fists
Gloves of Running Urgently : index (239) class weapon : tf_weapon_fists
Frying Pan : index (264) class weapon : saxxy
Warrior's Spirit : index (310) class weapon : tf_weapon_fists
Fists of Steel : index (331) class weapon : tf_weapon_fists
Saxxy : index (423) class weapon : saxxy
The Eviction Notice : index (426) class weapon : tf_weapon_fists
The Conscientious Objector : index (474) class weapon : saxxy
Apoco-Fists : index (587) class weapon : tf_weapon_fists
The Holiday Punch : index (656) class weapon : tf_weapon_fists
The Freedom Staff : index (880) class weapon : saxxy
The Bat Outta Hell : index (939) class weapon : saxxy
The Memory Maker : index (954) class weapon : saxxy
The Ham Shank : index (1013) class weapon : saxxy
Gold Frying Pan : index (1071) class weapon : saxxy
Festive Gloves of Running Urgently (G.R.U.) : index (1084) class weapon : tf_weapon_fists
The Bread Bite : index (1100) class weapon : tf_weapon_fists
The Necro Smasher : index (1123) class weapon : saxxy
The Crossing Guard : index (1127) class weapon : saxxy
Gloves of Running Urgently MvM : index (1184) class weapon : tf_weapon_fists
Prinny Machete : index (30758) class weapon : saxxy

(ahora los menus del engineer, Primary [Slot 0])
Primary [Slot 0] :
Engineer's Shotgun : index (9) class weapon : tf_weapon_shotgun_primary
Shotgun (Renamed/Strange) : index (199) class weapon : 	tf_weapon_shotgun
The Frontier Justice : index (141) class weapon : tf_weapon_sentry_revenge
The Widowmaker : index (527)  class weapon : tf_weapon_shotgun_primary
The Pomson 6000 : index (588) class weapon : tf_weapon_drg_pomson
The Rescue Ranger : index (997) class weapon : 	tf_weapon_shotgun_building_rescue
Festive Frontier Justice : index (1004) class weapon : tf_weapon_sentry_revenge
Festive Shotgun : index (1141) class weapon : tf_weapon_shotgun
Panic Attack : index (1153) class weapon : tf_weapon_shotgun
Backwoods Boomstick : index (15003) class weapon : tf_weapon_shotgun
Rustic Ruiner : index (15016) class weapon : tf_weapon_shotgun
Civic Duty : index (15044) class weapon : tf_weapon_shotgun
Lightning Rod : index (15047) class weapon : tf_weapon_shotgun
Autumn : index (15085) class weapon : tf_weapon_shotgun
Flower Power : index (15109) class weapon : tf_weapon_shotgun
Coffin Nail : index (15132) class weapon : tf_weapon_shotgun
Dressed to Kill : index (15133) class weapon : tf_weapon_shotgun
Red Bear : index (15152) class weapon : tf_weapon_shotgun

(segundo menu del engineer, Secondary [Slot 1])
Secondary [Slot 1]:
Engineer's Pistol : index (22) class weapon : tf_weapon_pistol
Pistol (Renamed/Strange) : index (209) class weapon : tf_weapon_pistol
The Wrangler : index (140) class weapon : tf_weapon_laser_pointer
Vintage Lugermorph : index (160) class weapon : tf_weapon_pistol
Lugermorph : index (294) class weapon : tf_weapon_pistol
The Short Circuit : index (528) class weapon : tf_weapon_mechanical_arm
Festive Wrangler : index (1086) class weapon : tf_weapon_laser_pointer
Red Rock Roscoe : index (15013) class weapon : tf_weapon_pistol
Homemade Heater : index (15018) class weapon : tf_weapon_pistol
Hickory Holepuncher : index (15035) class weapon : tf_weapon_pistol
Local Hero : index (15041) class weapon : tf_weapon_pistol
Black Dahlia : index (15046) class weapon : tf_weapon_pistol
Sandstone Special : index (15056) class weapon : tf_weapon_pistol
Macabre Web : index (15060) class weapon : tf_weapon_pistol
Nutcracker : index (15061) class weapon : tf_weapon_pistol
Blue Mew : index (15100) class weapon : tf_weapon_pistol
Brain Candy : index (15101) class weapon : tf_weapon_pistol
Shot to Hell : index (15102) class weapon : tf_weapon_pistol
Dressed To Kill : index (15126) class weapon : tf_weapon_pistol
Blitzkrieg : index (15148) class weapon : tf_weapon_pistol
The C.A.P.P.E.R. : index (30666) class weapon : tf_weapon_pistol
The Gigar Counter : index (30668) class weapon : tf_weapon_laser_pointer

(tercer menu del engineer, Melee [Slot 2])
Melee [Slot 2]:
Wrench : index (7) class weapon : tf_weapon_wrench
Wrench (Renamed/Strange) : index (197) class weapon : tf_weapon_wrench
The Gunslinger : index (142) class weapon : tf_weapon_robot_arm
The Southern Hospitality : index (155) class weapon : tf_weapon_wrench
Golden Wrench : index (169) class weapon : tf_weapon_wrench
The Jag : index (329) class weapon : tf_weapon_wrench
Saxxy : index (423) class weapon : saxxy
The Eureka Effect : index (589) class weapon : tf_weapon_wrench
Festive Wrench : index (662) class weapon : tf_weapon_wrench
Silver Botkiller Wrench Mk.I : index (795) class weapon : tf_weapon_wrench
Gold Botkiller Wrench Mk.I : index (804) class weapon : tf_weapon_wrench
Rust Botkiller Wrench Mk.I : index (884) class weapon : tf_weapon_wrench
Blood Botkiller Wrench Mk.I : index (893) class weapon : tf_weapon_wrench
Carbonado Botkiller Wrench Mk.I : index (902) class weapon : tf_weapon_wrench
Diamond Botkiller Wrench Mk.I : index (911) class weapon : tf_weapon_wrench
Silver Botkiller Wrench Mk.II : index (960) class weapon : tf_weapon_wrench
Gold Botkiller Wrench Mk.II : index (969) class weapon : tf_weapon_wrench
Gold Frying Pan : index (1071) class weapon : saxxy
The Necro Smasher : index (1123) class weapon : saxxy
Nutcracker : index (15073) class weapon : tf_weapon_wrench
Autumn : index (15074) class weapon : tf_weapon_wrench
Boneyard : index (15075) class weapon : tf_weapon_wrench
Dressed to Kill : index (15139) class weapon : tf_weapon_wrench
Top Shelf : index (15140) class weapon : tf_weapon_wrench
Torqued to Hell : index (15154) class weapon : tf_weapon_wrench
Airwolf : index (15156) class weapon : tf_weapon_wrench
Prinny Machete : index (30758) class weapon : saxxy

(ahora los menus del medic, Primary [Slot 0])
Primary [Slot 0]:
Syringe Gun : index (17) class weapon : tf_weapon_syringegun_medic
Syringe Gun (Renamed/Strange) : index (204) class weapon : tf_weapon_syringegun_medic
The Blutsauger : index (36) class weapon : tf_weapon_syringegun_medic
Crusader's Crossbow : index (305) class weapon : tf_weapon_crossbow
The Overdose : index (412) class weapon : tf_weapon_syringegun_medic
Festive Crusader's Crossbow : index (1079) class weapon : tf_weapon_crossbow

(ahora segundo menu del medic, Secondary [Slot 1])
Medi Gun : index (29) class weapon : tf_weapon_medigun
Medi Gun (Renamed/Strange) : index (211) class weapon : tf_weapon_medigun
The Kritzkrieg : index (35) class weapon : tf_weapon_medigun
The Quick-Fix : index (411) class weapon : tf_weapon_medigun
Festive Medi Gun : index (663) class weapon : tf_weapon_medigun
Silver Botkiller Medi Gun Mk.I : index (796) class weapon : tf_weapon_medigun
Gold Botkiller Medi Gun Mk.I : index (805) class weapon : tf_weapon_medigun
Rust Botkiller Medi Gun Mk.I : index (885) class weapon : tf_weapon_medigun
Blood Botkiller Medi Gun Mk.I : index (894) class weapon : tf_weapon_medigun
Carbonado Botkiller Medi Gun Mk.I : index (903) class weapon : tf_weapon_medigun
Diamond Botkiller Medi Gun Mk.I : index (912) class weapon : tf_weapon_medigun
Silver Botkiller Medi Gun Mk.II : index (961) class weapon : tf_weapon_medigun
Gold Botkiller Medi Gun Mk.II : index (970) class weapon : tf_weapon_medigun
The Vaccinator : index (998) class weapon : tf_weapon_medigun
Masked Mender : index (15008) class weapon : tf_weapon_medigun
Wrapped Reviver : index (15010) class weapon : tf_weapon_medigun
Reclaimed Reanimator : index (15025) class weapon : tf_weapon_medigun
Civil Servant : index (15039) class weapon : tf_weapon_medigun
Spark of Life : index (15050) class weapon : tf_weapon_medigun
Wildwood : index (15075) class weapon : tf_weapon_medigun
Flower Power : index (15097) class weapon : tf_weapon_medigun
Dressed To Kill : index (15121) class weapon : tf_weapon_medigun
High Roller's : index (15122) class weapon : tf_weapon_medigun
Coffin Nail : index (15123) class weapon : tf_weapon_medigun
Blitzkrieg : index (15145) class weapon : tf_weapon_medigun
Corsair : index (15146) class weapon : tf_weapon_medigun

(ahora el tercer menu del medic, Melee [Slot 2])
Melee [Slot 2]:
Bonesaw : index (8) class weapon : tf_weapon_bonesaw
Bonesaw (Renamed/Strange) : index (198) class weapon : tf_weapon_bonesaw
The Ubersaw : index (37) class weapon : tf_weapon_bonesaw
The Vita-Saw : index (173) class weapon : tf_weapon_bonesaw
Frying Pan : index (264) class weapon : saxxy
Amputator : index (304) class weapon : tf_weapon_bonesaw
The Solemn Vow : index (413) class weapon : tf_weapon_bonesaw
Saxxy : index (423) class weapon : saxxy
The Conscientious Objector : index (474) class weapon : saxxy
The Freedom Staff : index (880) class weapon : saxxy
The Bat Outta Hell : index (939) class weapon : saxxy
The Memory Maker : index (954) class weapon : saxxy
Festive Ubersaw : index (1003) class weapon : tf_weapon_bonesaw
The Ham Shank : index (1013) class weapon : saxxy
Gold Frying Pan : index (1071) class weapon : saxxy
The Necro Smasher : index (1123) class weapon : saxxy
The Crossing Guard : index (1127) class weapon : saxxy
Festive Bonesaw : index (1143) class weapon : tf_weapon_bonesaw
Prinny Machete : index (30758) class weapon : saxxy

(ahora los menus del sniper, Primary [Slot 0])
Primary [Slot 0]:
Sniper Rifle : index (14) class weapon : tf_weapon_sniperrifle
Sniper Rifle (Renamed/Strange) : index (201) class weapon : tf_weapon_sniperrifle
The Huntsman : index (56) class weapon : tf_weapon_compound_bow
The Sydney Sleeper : index (230) class weapon : tf_weapon_sniperrifle
The Bazaar Bargain : index (402) class weapon : tf_weapon_sniperrifle_decap
The Machina : index (526) class weapon : tf_weapon_sniperrifle
Festive Sniper Rifle : index (664) class weapon : tf_weapon_sniperrifle
The Hitman's Heatmaker : index (752) class weapon : tf_weapon_sniperrifle
Silver Botkiller Sniper Rifle Mk.I : index (792) class weapon : tf_weapon_sniperrifle
Gold Botkiller Sniper Rifle Mk.I : index (801) class weapon : tf_weapon_sniperrifle
The AWPer Hand : index (851) class weapon : tf_weapon_sniperrifle
Rust Botkiller Sniper Rifle Mk.I : index (881) class weapon : tf_weapon_sniperrifle
Blood Botkiller Sniper Rifle Mk.I : index (890) class weapon : tf_weapon_sniperrifle
Carbonado Botkiller Sniper Rifle Mk.I : index (899) class weapon : tf_weapon_sniperrifle
Diamond Botkiller Sniper Rifle Mk.I : index (908) class weapon : tf_weapon_sniperrifle
Silver Botkiller Sniper Rifle Mk.II : index (957) class weapon : tf_weapon_sniperrifle
Gold Botkiller Sniper Rifle Mk.II : index (966) class weapon : tf_weapon_sniperrifle
Festive Huntsman : index (1005) class weapon : tf_weapon_compound_bow
The Fortified Compound : index (1092) class weapon : tf_weapon_compound_bow
The Classic : index (1098) class weapon : tf_weapon_sniperrifle_classic
Night Owl : index (15003) class weapon : tf_weapon_sniperrifle
Purple Range : index (15007) class weapon : tf_weapon_sniperrifle
Lumber From Down Under : index (15019) class weapon : tf_weapon_sniperrifle
Shot in the Dark : index (15023) class weapon : tf_weapon_sniperrifle
Bogtrotter : index (15033) class weapon : tf_weapon_sniperrifle
Thunderbolt : index (15039) class weapon : tf_weapon_sniperrifle
Pumpkin Patch : index (15070) class weapon : tf_weapon_sniperrifle
Boneyard : index (15071) class weapon : tf_weapon_sniperrifle
Wildwood : index (15072) class weapon : tf_weapon_sniperrifle
Balloonicorn : index (15111) class weapon : tf_weapon_sniperrifle
Rainbow : index (15112) class weapon : tf_weapon_sniperrifle
Coffin Nail : index (15123) class weapon : tf_weapon_sniperrifle
Dressed to Kill : index (15136) class weapon : tf_weapon_sniperrifle
Airwolf : index (15154) class weapon : tf_weapon_sniperrifle
Shooting Star : index (30665) class weapon : tf_weapon_sniperrifle

(ahora el segundo menu del sniper, Secondary [Slot 1])
Secondary [Slot 1]:
SMG : index (16) class weapon : tf_weapon_smg
SMG (Renamed/Strange) : index (203) class weapon : tf_weapon_smg
The Razorback : index (57) class weapon : tf_wearable_razorback
Jarate : index (58) class weapon : tf_weapon_jar
Darwin's Danger Shield : index (231) class weapon : tf_wearable
Cozy Camper : index (642) class weapon : tf_wearable
The Cleaner’s Carbine : index (751) tf_weapon_charged_smg
Festive Jarate : index (1083) class weapon : tf_weapon_jar
The Self-Aware Beauty Mark : index (1105) class weapon : tf_weapon_jar
Festive SMG : index (1149) class weapon : tf_weapon_smg
Woodsy Widowmaker : index (15001) class weapon : tf_weapon_smg
Plaid Potshotter : index (15022) class weapon : tf_weapon_smg
Treadplate Tormenter : index (15032) class weapon : tf_weapon_smg
Team Sprayer : index (15037) class weapon : tf_weapon_smg
Low Profile : index (15058) class weapon : tf_weapon_smg
Wildwood : index (15076) class weapon : tf_weapon_smg
Blue Mew : index (15110) class weapon : tf_weapon_smg
High Roller's : index (15134) class weapon : tf_weapon_smg
Blitzkrieg : index (15153) class weapon : tf_weapon_smg

(ahora el tercer menu del sniper, Melee [Slot 2])
Melee [Slot 2] :
Kukri : index (3) class weapon : tf_weapon_club
Kukri (Renamed/Strange) : index (193) class weapon : tf_weapon_club
The Tribalman's Shiv : index (171) class weapon : tf_weapon_club
The Bushwacka : index (232) class weapon : tf_weapon_club
Frying Pan : index (264) class weapon : saxxy
The Shahanshah : index (401) class weapon : tf_weapon_club
Saxxy : index (423) class weapon : saxxy
The Conscientious Objector : index (474)
The Freedom Staff : index (880) class weapon : saxxy
The Bat Outta Hell : index (939) class weapon : saxxy
The Memory Maker : index (954) class weapon : saxxy
The Ham Shank : index (1013) class weapon : saxxy
Gold Frying Pan : index (1071) class weapon : saxxy
The Necro Smasher : index (1123) class weapon : saxxy
The Crossing Guard : index (1127) class weapon : saxxy
Prinny Machete : index (30758) class weapon : saxxy

(ahora los menus del spy, Secondary [Slot 0])
Secondary [Slot 0]:
Revolver : index (24) class weapon : tf_weapon_revolver
Revolver (Renamed/Strange) : index (210) class weapon : tf_weapon_revolver
The Ambassador : index (61) class weapon : tf_weapon_revolver
Big Kill : index (161) class weapon : tf_weapon_revolver
L'Etranger : index (224) class weapon : tf_weapon_revolver
The Enforcer : index (460) class weapon : tf_weapon_revolver
The Diamondback : index (525) class weapon : tf_weapon_revolver
Festive Ambassador : index (1006) class weapon : tf_weapon_revolver
Festive Revolver : index (1142) class weapon : tf_weapon_revolver
Psychedelic Slugger : index (15011) class weapon : tf_weapon_revolver
Old Country : index (15027) class weapon : tf_weapon_revolver
Mayor : index (15042) class weapon : tf_weapon_revolver
Dead Reckoner : index (15051) class weapon : tf_weapon_revolver
Boneyard : index (15062) class weapon : tf_weapon_revolver
Wildwood : index (15063) class weapon : tf_weapon_revolver
Macabre Web : index (15064) class weapon : tf_weapon_revolver
Flower Power : index (15073) class weapon : tf_weapon_revolver
Top Shelf : index (15128) class weapon : tf_weapon_revolver
Coffin Nail : index (15127) class weapon : tf_weapon_revolver
Blitzkrieg : index (15149) class weapon : tf_weapon_revolver

(segundo menu del spy, Building [Slot 1])
Building [Slot 1]:
Sapper : index (735) class weapon : tf_weapon_builder
Sapper (Renamed/Strange) : index (736) class weapon : tf_weapon_builder
The Red-Tape Recorder : index (810) class weapon : tf_weapon_sapper
The Red-Tape Recorder (Genuine) : index (831) class weapon : tf_weapon_sapper
The Ap-Sap (Genuine) : index (933) class weapon : tf_weapon_sapper
Festive Sapper : index (1080) class weapon : tf_weapon_sapper
The Snack Attack : index (1102) class weapon : tf_weapon_sapper

(tercer menu del spy, Melee [Slot 2])
Melee [Slot 2]:
Knife : index (4) class weapon : tf_weapon_knife
Knife (Renamed/Strange) : index (194) class weapon : tf_weapon_knife
Your Eternal Reward : index (225) class weapon : tf_weapon_knife
Conniver's Kunai : index (356) class weapon : tf_weapon_knife
Saxxy : index (423) class weapon : saxxy
The Big Earner : index (461) class weapon : tf_weapon_knife
The Wanga Prick : index (574) class weapon : tf_weapon_knife
The Sharp Dresser : index (638) class weapon : tf_weapon_knife
The Spy-cicle : index (649) class weapon : tf_weapon_knife
Festive Knife : index (665) class weapon : tf_weapon_knife
The Black Rose : index (727) class weapon : tf_weapon_knife
Silver Botkiller Knife Mk.I : index (794) class weapon : tf_weapon_knife
Gold Botkiller Knife Mk.I : index (803) class weapon : tf_weapon_knife
Rust Botkiller Knife Mk.I : index (883) class weapon : tf_weapon_knife
Blood Botkiller Knife Mk.I : index (892) class weapon : tf_weapon_knife
Carbonado Botkiller Knife Mk.I : index (901) class weapon : tf_weapon_knife
Diamond Botkiller Knife Mk.I : index (910) class weapon : tf_weapon_knife
Silver Botkiller Knife Mk.II : index (959) class weapon : tf_weapon_knife
Gold Botkiller Knife Mk.II : index (968) class weapon : tf_weapon_knife
Gold Frying Pan : index (1071) class weapon : saxxy
Boneyard : index (15062) class weapon : tf_weapon_knife
Blue Mew : index (15094) class weapon : tf_weapon_knife
Brain Candy : index (15095) class weapon : tf_weapon_knife
Stabbed to Hell : index (15096) class weapon : tf_weapon_knife
Dressed to Kill : index (15118) class weapon : tf_weapon_knife
Top Shelf : index (15119) class weapon : tf_weapon_knife
Blitzkrieg : index (15143) class weapon : tf_weapon_knife
Airwolf : index (15144) class weapon : tf_weapon_knife
Prinny Machete : index (30758) class weapon : saxxy

(cuarto menu del spy, PDA2 [Slot 4])
PDA2 [Slot 4]:
Invis Watch : index (30) class weapon : tf_weapon_invis
Invis Watch (Renamed/Strange) : index (212) class weapon : tf_weapon_invis
The Dead Ringer : index (59) class weapon : tf_weapon_invis
The Cloak and Dagger : index (60) class weapon : tf_weapon_invis
Enthusiast's Timepiece : index (297) class weapon : tf_weapon_invis
The Quäckenbirdt : index (947) class weapon : tf_weapon_invis

tf_econ_data:
/**
 * [TF2] Econ Data
 * Functions to read item information from game memory.
 */

#if defined __tf_econ_data_included
	#endinput
#endif

#include <tf2_stocks>

#define __tf_econ_data_included

/**
 * Item definition index for the special "default" item entry, which is returned by the game's
 * CEconItemSchema::GetItemDefinition() if the given item definition does not exist.
 * 
 * Not a valid item, but points to a valid item definition, so this does return information when
 * `TF2Econ_Get*` functions are called on it.
 */
enum {
	TF_ITEMDEF_DEFAULT = -1,
};

/**
 * Value for TF2Econ_GetParticleAttributeList to look up the items in a specific list.
 */
enum TFEconParticleSet {
	ParticleSet_All,
	ParticleSet_CosmeticUnusualEffects,
	ParticleSet_WeaponUnusualEffects,
	ParticleSet_TauntUnusualEffects
};

/**
 * Callback for `TF2Econ_GetItemList`.  Return `true` if the specified item definition index
 * should be added to the returned `ArrayList`.
 */
typedef ItemFilterCriteria = function bool(int itemdef, any data);

/**
 * Callback for `TF2Econ_GetAttributeList`.  Return `true` if the specified attribute definition
 * index should be added to the returned `ArrayList`.
 * 
 * This prototype is the same as `TF2Econ_GetItemList`.  Take care to not mix up the callbacks.
 */
typedef AttributeFilterCriteria = function bool(int attrdef, any data);

/**
 * Returns true if there is an item corresponding to the given item definition index.
 * TF_ITEMDEF_DEFAULT returns false here.
 */
native bool TF2Econ_IsValidItemDefinition(int itemdef);

/**
 * Returns true if item is in base set (corresponds to the "baseitem" key).
 */
native bool TF2Econ_IsItemInBaseSet(int itemdef);

/**
 * Returns the item's name (corresponds to the "name" key).
 */
native bool TF2Econ_GetItemName(int itemdef, char[] name, int maxlen);

/**
 * Returns the item's localization token name (corresponds to the "item_name" key).
 */
native bool TF2Econ_GetLocalizedItemName(int itemdef, char[] name, int maxlen);

/**
 * Stores the item class name in the given buffer and returns true if given a valid item
 * definition, otherwise returns false.
 */
native bool TF2Econ_GetItemClassName(int itemdef, char[] buffer, int maxlen);

/**
 * Returns the item's loadout slot for the given class, or -1 if the item definition or
 * item / class combination is not valid.  This is *not* the same value as the weapon slot used
 * in SourceMod's GetPlayerWeaponSlot native; not all values match.
 * 
 * More information about this distinction is available here:
 * https://github.com/nosoop/SM-TFEconData/wiki/Porting-TF2IDB-and-TF2II-plugins-to-TFEconData#notes-about-loadout-slots
 */
native int TF2Econ_GetItemLoadoutSlot(int itemdef, TFClassType playerClass);

/**
 * Returns the item's default loadout slot.
 */
native int TF2Econ_GetItemDefaultLoadoutSlot(int itemdef);

/**
 * Returns the given item's equipment region mask.  This mask can be and-tested with another
 * mask to determine if items conflict.
 */
native int TF2Econ_GetItemEquipRegionMask(int itemdef);

/**
 * Returns the given item's equipment region groups as a bitfield.
 * 
 * Internally, this is called an EquipRegionBitMask, but for the sake of clarity it's been
 * renamed in this library to specify equip region groups.
 */
native int TF2Econ_GetItemEquipRegionGroupBits(int itemdef);

/**
 * Stores the minimum and maximum item level range in the given cell references and
 * returns true for a valid item definition, otherwise returns false.
 */
native bool TF2Econ_GetItemLevelRange(int itemdef, int &iMinLevel, int &iMaxLevel);

/**
 * Returns the given item's statically defined quality.
 */
native int TF2Econ_GetItemQuality(int itemdef);

/**
 * Returns the given item's rarity, or -1 if the item does not have a statically defined rarity.
 */
native int TF2Econ_GetItemRarity(int itemdef);

/**
 * Returns an `ArrayList` containing attribute defindex / value pairs corresponding to the given
 * item definition, or `null` if not a valid item definition.
 * 
 * The `ArrayList` has a blocksize of 2.  Block 0 contains the attribute defindex; block 1
 * contains the attribute value, which is a 32-bit value that may represent an int, float, or
 * pointer to a complex type.
 * 
 * This handle is owned by the calling plugin, so it should be `delete`d when not needed
 * anymore.
 */
native ArrayList TF2Econ_GetItemStaticAttributes(int itemdef);

/**
 * Returns an arbitrary string from an item definition's KeyValues structure.
 * You may use subkey notation ('/') to retrieve nested values.
 * 
 * Returns true if the output buffer is not empty.
 */
native bool TF2Econ_GetItemDefinitionString(int itemdef, const char[] key,
		char[] buffer, int maxlen, const char[] defaultValue = "");

/**
 * Returns an ArrayList containing all valid item definition indices.  If an ItemFilterCriteria
 * callback is passed in, the ArrayList only contains defindexes that the callback returned
 * `true` on.
 * 
 * The resulting ArrayList does not have a defined order.
 * 
 * This handle is owned by the calling plugin, so it should be `delete`d when not needed
 * anymore.
 */
native ArrayList TF2Econ_GetItemList(ItemFilterCriteria func = INVALID_FUNCTION, any data = 0);

/**
 * Returns true if the specified className was translated for the given player class.
 * The buffer is not modified if the className was not translated.
 * 
 * This is used for multiclass weapons -- if given a player class-specific classname,
 * this function returns false.
 */
native bool TF2Econ_TranslateWeaponEntForClass(char[] className, int maxlen,
		TFClassType playerClass);

/**
 * Returns true if the given loadout slot index has a name, false otherwise.
 */
native bool TF2Econ_TranslateLoadoutSlotIndexToName(int index, char[] buffer, int maxlen);

/**
 * Returns the loadout slot index for the given slot name, or -1 if not a valid slot.
 */
native int TF2Econ_TranslateLoadoutSlotNameToIndex(const char[] slotName);

/**
 * Returns the number of valid loadout slots.
 */
native int TF2Econ_GetLoadoutSlotCount();

/**
 * Returns true if there is an attribute corresponding to the given attribute definition index.
 */
native bool TF2Econ_IsValidAttributeDefinition(int attrdef);

/**
 * Returns true if the attribute is considered hidden (corresponds to the "hidden" key).
 */
native bool TF2Econ_IsAttributeHidden(int attrdef);

/** 
 * Returns true if the attribute is stored as an integer (corresponds to the "stored_as_integer"
 * key).
 * 
 * Not sure when this is actually used -- certain attributes such as
 * "mod max primary clip override" are flagged as true, but are float values when retrieved
 * via `TF2Econ_GetItemStaticAttributes()`.
 */
native bool TF2Econ_IsAttributeStoredAsInteger(int attrdef);

/**
 * Stores the attribute name in the given buffer and returns true if given a valid attribute
 * definition, otherwise returns false.
 */
native bool TF2Econ_GetAttributeName(int attrdef, char[] buffer, int maxlen);

/**
 * Stores the attribute class name in the given buffer and returns true if given a valid
 * attribute definition, otherwise returns false.
 */
native bool TF2Econ_GetAttributeClassName(int attrdef, char[] buffer, int maxlen);

/**
 * Returns an arbiitrary string from an item attribute definition's KeyValues structure.
 * You may use subkey notation ('/') to retrieve nested values.
 * 
 * Returns true if the output buffer is not empty.
 */
native bool TF2Econ_GetAttributeDefinitionString(int attrdef, const char[] key,
		char[] buffer, int maxlen, const char[] defaultValue = "");

/**
 * Returns the attribute definition index for a given name, or -1 if the name does not
 * correspond to an attribute.
 */
native int TF2Econ_TranslateAttributeNameToDefinitionIndex(const char[] name);

/**
 * Returns an ArrayList containing all valid attribute definition indices.  If an
 * AttributeFilterCriteria callback is passed in, the ArrayList only contains attribute
 * definition indices that the callback returned `true` on.
 * 
 * The resulting ArrayList does not have a defined order.
 * 
 * This handle is owned by the calling plugin, so it should be `delete`d when not needed
 * anymore.
 */
native ArrayList TF2Econ_GetAttributeList(AttributeFilterCriteria func = INVALID_FUNCTION,
		any data = 0);

/**
 * Stores the quality name in the given buffer and returns true if given a valid quality value,
 * otherwise returns false;
 */
native bool TF2Econ_GetQualityName(int quality, char[] buffer, int maxlen);

/**
 * Returns the quality value for a given name, or -1 if the name does not correspond to an item
 * quality.
 */
native int TF2Econ_TranslateQualityNameToValue(const char[] name, bool caseSensitive = true);

/**
 * Returns an ArrayList containing all valid quality values.
 * 
 * This handle is owned by the calling plugin, so it should be `delete`d when not needed
 * anymore.
 */
native ArrayList TF2Econ_GetQualityList();

/**
 * Stores the rarity name in the given buffer and returns true if given a valid rarity value,
 * otherwise returns false;
 * 
 * Note:  Rarity names returned by this value correspond to the localized "weapon grade" names,
 * but are completely different.  "Civilian Grade" corresponds to "common", "Freelance Grade" to
 * "uncommon", and so on.
 */
native bool TF2Econ_GetRarityName(int rarity, char[] buffer, int maxlen);

/**
 * Returns the rarity value for a given name, or -1 if the name does not correspond to an item
 * rarity.
 */
native int TF2Econ_TranslateRarityNameToValue(const char[] name, bool caseSensitive = true);

/**
 * Returns an ArrayList containing all valid rarity values.
 * 
 * This handle is owned by the calling plugin, so it should be `delete`d when not needed
 * anymore.
 */
native ArrayList TF2Econ_GetRarityList();

/**
 * Returns a StringMap containing all valid equip region names mapped to their equip region
 * group indices.
 */
native StringMap TF2Econ_GetEquipRegionGroups();

/**
 * Returns true if the given equip region name is valid, storing its equip region mask in the
 * given by-ref``mask` argument.
 */
native bool TF2Econ_GetEquipRegionMask(const char[] equipRegion, int &mask);

/**
 * Stores the "system" name for the given particle attribute index in the given buffer.
 * Returns true if the index corresponds to a particle, false otherwise.
 */
native bool TF2Econ_GetParticleAttributeSystemName(int particleIndex, char[] buffer, int maxlen);

/**
 * Returns an ArrayList containing all particle attribute values, or just those in a particular
 * set (currently valid sets are for cosmetic, taunt, or weapon effects).  Particle effects in
 * the "other_particles" and "killstreak_eyeglows" categories are only available in "all" set.
 * 
 * Throws an error if the given TFEconParticleSet value is not recognized.
 * 
 * Handle is owned by the calling plugin.
 */
native ArrayList TF2Econ_GetParticleAttributeList(
		TFEconParticleSet particleSet = ParticleSet_All);

/**
 * Returns an ArrayList containing all valid paint kit protodef indices.  `delete` when
 * unneeded.
 * 
 * This includes paint kits that are only applied to weapons, but does not include unused paint
 * kits (as defined in resource/tf_proto_obj_defs_english.txt and other languages).
 * 
 * Handle is owned by the calling plugin.
 */
native ArrayList TF2Econ_GetPaintKitDefinitionList();

/**
 * Returns the definition index of a given map name, or 0 if not valid.
 * 
 * Note that the name "Missing" also points to a valid map definition, and will also return 0;
 * the zero-on-invalid case is intended to match the behavior of the game.
 */
native int TF2Econ_GetMapDefinitionIndexByName(const char[] name);

/**
 * Returns the address of the singleton CTFItemSchema (subclass of CEconItemSchema).
 * 
 * Here be dragons.
 */
native Address TF2Econ_GetItemSchemaAddress();

/**
 * Returns the address of the singleton CProtoBufScriptObjectDefinitionManager.
 * 
 * Here be dragons.
 */
native Address TF2Econ_GetProtoDefManagerAddress();

/**
 * Returns the address of the CEconItemDefinition for the item with the given definition index,
 * or Address_Null if not valid.  The special "default" item definition is returned iff
 * TF_ITEMDEF_DEFAULT is used as the defindex.
 * 
 * Here be dragons.
 */
native Address TF2Econ_GetItemDefinitionAddress(int itemdef);

/**
 * Returns the address of the CEconItemAttributeDefinition for the attribute with the given
 * definition index, or Address_Null if not valid.
 * 
 * Here be dragons.
 */
native Address TF2Econ_GetAttributeDefinitionAddress(int attrdef);

/**
 * Returns the address of the CEconItemRarityDefinition for the rarity with the given value,
 * or Address_Null if not valid.
 * 
 * You know the drill at this point.
 */
native Address TF2Econ_GetRarityDefinitionAddress(int rarity);

/**
 * Returns the address of the attachedparticlesystem_t for the system corresponding to the given
 * index, or Address_Null if not valid.
 */
native Address TF2Econ_GetParticleAttributeAddress(int particleIndex);

/**
 * Returns the address of the CPaintKitDefinition for the paintkit with the given protodef
 * index, or Address_Null if not valid.
 */
native Address TF2Econ_GetPaintKitDefinitionAddress(int protoDefIndex);

/**
 * @deprecated Renamed native to TF2Econ_IsValidItemDefinition so there is a better distinction
 * between item and attribute definitions.
 * 
 * This native will still be present for backwards compatibility.
 */
#pragma deprecated Use TF2Econ_IsValidItemDefinition instead
native bool TF2Econ_IsValidDefinitionIndex(int itemdef);

/**
 * @deprecated Renamed native to TF2Econ_GetItemLoadoutSlot to remove the confusion on weapon
 * and loadout slots.
 * 
 * This native will still be present for backwards compatibility.
 */
#pragma deprecated Use TF2Econ_GetItemLoadoutSlot instead
native int TF2Econ_GetItemSlot(int itemdef, TFClassType playerClass);

public SharedPlugin __pl_tf_econ_data = {
	name = "tf_econ_data",
	file = "tf_econ_data.smx",
#if defined REQUIRE_PLUGIN
	required = 1,
#else
	required = 0,
#endif
};

tf2items:
#if defined _tf2items_included
#endinput
#endif
#define _tf2items_included

#include <tf2>

// ====[ CONSTANTS ]===========================================================
#define OVERRIDE_CLASSNAME		(1 << 0)	// Item will override the entity's classname.
#define OVERRIDE_ITEM_DEF			(1 << 1)	// Item will override the item's definition index.
#define OVERRIDE_ITEM_LEVEL		(1 << 2)	// Item will override the entity's level.
#define OVERRIDE_ITEM_QUALITY		(1 << 3)	// Item will override the entity's quality.
#define OVERRIDE_ATTRIBUTES		(1 << 4)	// Item will override the attributes for the item with the given ones.
#define OVERRIDE_ALL				(0b11111)	// Magically enables all the other flags.

#define PRESERVE_ATTRIBUTES		(1 << 5)
#define FORCE_GENERATION		(1 << 6)

// ====[ NATIVES ]=============================================================

/**
 * WARNING: This is for ADVANCED users only!
 * You probably want to be using the forward instead of this.
 *
 * This native will perform a GiveNamedItem call for the specified client in
 * order to generate an object based on the specifications of the TF2Items
 * object passed to it.
 * 
 * Since the item generation requires all the information that can be passed by
 * the extensions natives, the flags will be ignored and all the given
 * information will be used.
 * 
 * Remember that if your values aren't correct, this call may end up in a crash,
 * so please make sure you fill out everything: Classname, item definition index,
 * quality, level and attributes.
 * 
 * @param iClient	Client that the item will be generated for.
 * @param hItem		Handle to the TF2Items object that we'll be operating with.
 * @return			Entity index of the newly created item.
 */
native TF2Items_GiveNamedItem(iClient, Handle:hItem);

/**
 * Creates a TF2Items object, wich can be used to override the parameters of an
 * item before it's given to the client, or to create a new completely new one
 * with GiveNamedItem. Remember to free the object with CloseHandle()
 *
 * @param iFlags		Flags used to specify what to override.
 * @return				Handle to the TFItems object.
 */
native Handle:TF2Items_CreateItem(iFlags);

/**
 * Sets the flags to determine what the item will override on the GiveNamedItem.
 * Use the OVERRIDE_ defines to set what you will be changing.
 *
 * @param hItem			Handle to the TF2Items object that we'll be operating with.
 * @param iFlags		Flags used to specify what to override.
 * @noreturn
 */
native TF2Items_SetFlags(Handle:hItem, iFlags);

/**
 * Sets the new entity classname used for the item's entity.
 *
 * @param hItem				Handle to the TF2Items object that we'll be operating with.
 * @param strClassName		New classname to use for the entity.
 * @noreturn
 */
native TF2Items_SetClassname(Handle:hItemOverride, String:strClassName[]);

/**
 * Sets the item's Definition Index, wich tells the game what item it is. Each
 * weapon/hat/item has an unique definition index. Find these out in the
 * game_items.txt
 * 
 * @param hItem				Handle to the TF2Items object that we'll be operating with.
 * @param iItemDefIndex		New definition index.
 * @noreturn
 */
native TF2Items_SetItemIndex(Handle:hItem, iItemDefIndex);

/**
 * Sets the item's quality value, wich determines what color will be used for
 * the item name. Valid values are from 0 to 9.
 * 
 * @param hItem					Handle to the TF2Items object that we'll be operating with.
 * @param iEntityQuality		New item quality.
 * @noreturn
 */
native TF2Items_SetQuality(Handle:hItem, iEntityQuality);

/**
 * Sets the item's level value. This value can range from 0 to 127.
 * 
 * @param hItem				Handle to the TF2Items object that we'll be operating with.
 * @param iEntityLevel		New item level.
 * @noreturn
 */
native TF2Items_SetLevel(Handle:hItem, iEntityLevel);

/**
 * Sets the number of attributes that will be used on the item. The maximum
 * number of attributes that can be allocated ranges from 0 to 15.
 * 
 * @param hItem					Handle to the TF2Items object that we'll be operating with.
 * @param iNumAttributes		Number of attributes.
 * @noreturn
 */
native TF2Items_SetNumAttributes(Handle:hItem, iNumAttributes);

/**
 * Setups the given attribute index to use the attribute and values specified
 * with iAttribDefIndex and flValue. Remember the iSlotIndex ranges from 0 to 15.
 * 
 * @param hItem					Handle to the TF2Items object that we'll be operating with.
 * @param iSlotIndex			The attribute slot index, ranges from 0 to 15.
 * @param iAttribDefIndex		The attribute definition index, as it appears on game_items.txt.
 * @param flValue				The value assigned to the attribute (how much health, damage, etc.).
 * @noreturn
 */
native TF2Items_SetAttribute(Handle:hItem, iSlotIndex, iAttribDefIndex, Float:flValue);

/**
 * Retrieves the flags used to determine what the item will override on the
 * GiveNamedItem call.
 *
 * @param hItem		Handle to the TF2Items object that we'll be operating with.
 * @return			Returns the flags used by the item.
 */
native TF2Items_GetFlags(Handle:hItem);

/**
 * Gets the entity classname we'll use for the item.
 *
 * @param hItem		Handle to the TF2Items object that we'll be operating with.
 * @return			New classname to use for the entity.
 */
native TF2Items_GetClassname(Handle:hItem, String:strDest[], iDestSize);

/**
 * Gets the new item definition index we'll use to override.
 *
 * @param hItem		Handle to the TF2Items object that we'll be operating with.
 * @return			New definition index.
 */
native TF2Items_GetItemIndex(Handle:hItem); 

/**
 * Gets the item's quality value, wich determines what color will be used for
 * the item name. Valid values are from 0 to 9. But if set to 0 and attributes
 * are also changed, this value will be overridden to 9
 *
 * @param hItem		Handle to the TF2Items object that we'll be operating with.
 * @return			New entity quality.
 */
native TF2Items_GetQuality(Handle:hItem); 

/**
 * Gets the item's level value. This value can range from 0 to 127.
 *
 * @param hItem		Handle to the TF2Items object that we'll be operating with.
 * @return			New entity level.
 */
native TF2Items_GetLevel(Handle:hItem);

/**
 * Gets the number of attributes that will be used on the item. The maximum
 * number of attributes that can be allocated ranges from 0 to 15.
 *
 * @param hItem		Handle to the TF2Items object that we'll be operating with.
 * @return			Number of attributes.
 */
native TF2Items_GetNumAttributes(Handle:hItem);

/**
 * Retrieves the attribute definition index used at the specified index on the
 * item object. Remember the iSlotIndex ranges from 0 to 15.
 *
 * @param hItem		Handle to the TF2Items object that we'll be operating with.
 * @return			The attribute definition index to use.
 */
native TF2Items_GetAttributeId(Handle:hItem, iSlotIndex);

/**
 * Retrieves the value used for the attribute at the specified index on the item
 * object. Remember the iSlotIndex ranges from 0 to 15.
 *
 * @param hItem		Handle to the TF2Items object that we'll be operating with.
 * @return			The attribute value to use.
 */
native Float:TF2Items_GetAttributeValue(Handle:hItem, iSlotIndex); 

// ====[ FORWARDS ]============================================================
/**
 * Called when an item is about to be given to a client.
 * Return Plugin_Changed to override the item to use the configuration of the hItem object.
 * Return Plugin_Continue to keep them intact.
 * Return Plugin_Handled to stop the item being given to the player.
 * Make sure the client gets atleast one weapon.
 *
 * @param client				Client Index.
 * @param classname				The classname of the entity that will be generated.
 * @param iItemDefinitionIndex	Item definition index.
 * @param hItem					Handle to a TF2Item object wich describes what values will be overriden.
 */
forward Action:TF2Items_OnGiveNamedItem(client, String:classname[], iItemDefinitionIndex, &Handle:hItem);

forward TF2Items_OnGiveNamedItem_Post(client, String:classname[], itemDefinitionIndex, itemLevel, itemQuality, entityIndex);

/**
 * Do not edit below this line!
 */
public Extension:__ext_tf2items = 
{
	name = "TF2Items",
	file = "tf2items.ext.2.ep2v",
	autoload = 0,
	#if defined REQUIRE_EXTENSIONS
		required = 1,
	#else
		required = 0,
	#endif
}
	
/**
* I'll just leave this here...
* 
* _(º< _(º< _(º< _(º< _(º< _(º< _(º< _(º< _(º< 
* \__) \__) \__) \__) \__) \__) \__) \__) \__) 
*                     .  .
*                    // //  __
*         __  ______||_//_.´.´
*       _/__`´            ¯ `
*      /  / _          _     \
*     /  /( · )      ( · )    |
*    /  |   ¯     __   ¯    _/\/|
*   |    \  ___.-´  `-.___  \   /
*    \    \(     ` ´      `)|   \
*     \     )              //     \
*      \/  /              | |     |
*     /   /               | |     |
*    ·   |                |  \___/
*    |    \_            _/      \  ____
*    ·      `----------´         |´    \
*     \                         /    _·´
*      \                       /  _-´ 
*        `-._               _·´-´
*        _.-´`---________--´ \ 
*       ´-.-. _--·   / .   ._ \
*            ´       `´ `·´  `´
* >º)_ >º)_ >º)_ >º)_ >º)_ >º)_ >º)_ >º)_ >º)_ 
* (__/ (__/ (__/ (__/ (__/ (__/ (__/ (__/ (__/ 
* 
*/

tf2atributtes:
#if defined _tf2attributes_included
  #endinput
#endif
#define _tf2attributes_included

/**
 * Sets an attribute's value on an entity, adding it if it isn't on the entity.
 *
 * @param iEntity		Entity index to set the attribute on. Must have m_AttributeList.
 * @param strAttrib		Name of the attribute, as from the "name" key in items_game.
 * @param flValue		Value to set the attribute to
 *
 * @return				True if the attribute was added successfully, false if entity does not have m_AttributeList.
 * @error				Invalid entity index or attribute name passed.
 */
native bool TF2Attrib_SetByName(int iEntity, const char[] strAttrib, float flValue);

/**
 * Sets an attribute's value on an entity, adding it if it isn't on the entity.
 *
 * @param iEntity		Entity index to set the attribute on. Must have m_AttributeList.
 * @param iDefIndex		Definition index of the attribute, as from the number on the attribute entry in items_game.
 * @param flValue		Value to set the attribute to
 *
 * @return				True if the attribute was added successfully, false if entity does not have m_AttributeList.
 * @error				Invalid entity index or attribute name passed.
 */
native bool TF2Attrib_SetByDefIndex(int iEntity, int iDefIndex, float flValue);

/**
 * Parses the attribute name and value strings and applies it on the entity.  This parses
 * numeric and string attributes.
 * 
 * If you use this on a non-numeric attribute, make sure that only the server reads off of that
 * attribute.  Non-primitive values aren't replicated correctly between the client and the
 * server; the client will read garbage and may crash!
 * 
 * @param iEntity		Entity index to set the attribute on. Must have m_AttributeList.
 * @param strAttrib		Name of the attribute, as from the "name" key in items_game.
 * @param strValue		Value to set the attribute to.
 * 
 * @return				True if the attribute was added successfully, false if the attribute name was invalid.
 * @error				Invalid entity index or entity does not have m_AttributeList.
 */
native bool TF2Attrib_SetFromStringValue(int iEntity, const char[] strAttrib, const char[] strValue);

/**
 * Returns the address of an attribute on an entity.
 *
 * @param iEntity		Entity index to get attribute from. Must have m_AttributeList.
 * @param strAttrib		Name of the attribute, as from the "name" key in items_game.
 *
 * @return				Address of the attribute on the entity, or Address_Null if the attribute does not exist on the entity.
 * @error				Invalid entity index or attribute name passed.
 */
native Address TF2Attrib_GetByName(int iEntity, const char[] strAttrib);

/**
 * Returns the address of an attribute (by attribute index) on an entity.
 *
 * @param iEntity		Entity index to get attribute from. Must have m_AttributeList.
 * @param iDefIndex		Definition index of the attribute, as from the number on the attribute entry in items_game.
 *
 * @return				Address of the attribute on the entity, or Address_Null if the attribute does not exist on the entity.
 * @error				Invalid entity index or attribute index passed.
 */
native Address TF2Attrib_GetByDefIndex(int iEntity, int iDefIndex);

/**
 * Removes an attribute from an entity.
 *
 * @param iEntity		Entity index to remove attribute from. Must have m_AttributeList.
 * @param strAttrib		Name of the attribute, as from the "name" key in items_game.
 *
 * @return				True if the SDKCall was made, false if entity had invalid address or m_AttributeList missing.
 * @error				Invalid entity index or attribute name passed.
 */
native bool TF2Attrib_RemoveByName(int iEntity, const char[] strAttrib);

/**
 * Removes an attribute from an entity.
 *
 * @param iEntity		Entity index to remove attribute from. Must have m_AttributeList.
 * @param iDefIndex		Definition index of the attribute, as from the number on the attribute entry in items_game.
 *
 * @return				True if the SDKCall was made, false if entity had invalid address or m_AttributeList missing.
 * @error				Invalid entity index or attribute index passed.
 */
native bool TF2Attrib_RemoveByDefIndex(int iEntity, int iDefIndex);

/**
 * Removes all attributes from an entity.
 *
 * @param iEntity		Entity index to remove attribute from. Must have m_AttributeList.
 *
 * @return				True if the SDKCall was made, false if entity had invalid address or m_AttributeList missing.
 * @error				Invalid entity index passed.
 */
native bool TF2Attrib_RemoveAll(int iEntity);

/**
 * Clears and presumably rebuilds the attribute cache for an entity, 'refreshing' attributes.
 * Call this after making changes to an attribute with any of the TF2Attrib_Set*(Address pAttrib, arg) natives below.
 * You may also need to call this on the entity's m_hOwnerEntity if it is a weapon or wearable.
 * You do NOT need to call this after calls to TF2Attrib_SetByName, TF2Attrib_Remove, and TF2Attrib_RemoveAll.
 *
 * @param iEntity		Entity index to remove attribute from. Must have m_AttributeList.
 *
 * @return				True if the SDKCall was made, false if entity had invalid address or m_AttributeList missing.
 * @error				Invalid entity index passed.
 */
native bool TF2Attrib_ClearCache(int iEntity);

/**
 * Sets the value of m_iAttributeDefinitionIndex (the attribute ID) on an attribute.
 * Warning, this changes what GetByName/ID and SetByName 'see' as the name of the attribute,
 * but will only change attribute's effects if TF2Attrib_ClearCache is called on the entity with the attribute after.
 *
 * @param pAttrib		Address of the attribute.
 * @param iDefIndex		Value to set m_iAttributeDefinitionIndex to.
 *
 * @noreturn
 */
native void TF2Attrib_SetDefIndex(Address pAttrib, int iDefIndex);

/**
 * Returns the value of m_iAttributeDefinitionIndex (the attribute ID) on an attribute.
 *
 * @param pAttrib		Address of the attribute.
 *
 * @return				The integer value of m_iAttributeDefinitionIndex on the attribute.
 */
native int TF2Attrib_GetDefIndex(Address pAttrib);

/**
 * Sets the value of m_flValue on an attribute.
 *
 * @param pAttrib		Address of the attribute.
 * @param flValue		Value to set m_flValue to.
 *
 * @noreturn
 */
native void TF2Attrib_SetValue(Address pAttrib, float flValue);

/**
 * Returns the value of m_flValue on an attribute.
 *
 * @param pAttrib		Address of the attribute.
 *
 * @return				The floating point value of m_flValue on the attribute.
 */
native float TF2Attrib_GetValue(Address pAttrib);

/**
 * Returns the string data from its raw value representation (a CAttribute_String instance).
 * 
 * WARNING: This dereferences the input value!  Feeding it values that aren't CAttribute_String pointers will result in unexpected behavior, potentially crashing the server.
 * In the case where you only want the currently active value, use TF2Attrib_HookValueString instead.
 * 
 * @param pRawValue		Raw attribute value.  You can get this value with either TF2Attrib_GetValue, TF2Attrib_GetSOCAttribs, or TF2Attrib_GetStaticAttribs.
 * @param buffer		Buffer to store the resulting string to.
 * @param maxlen		Maximum length of the buffer.
 * 
 * @return Number of bytes written.
 */
native int TF2Attrib_UnsafeGetStringValue(any pRawValue, char[] buffer, int maxlen);

/**
 * Sets the value of m_nRefundableCurrency on an attribute.
 *
 * @param pAttrib		Address of the attribute.
 * @param nCurrency		Value to set m_nRefundableCurrency to.
 *
 * @noreturn
 */
native void TF2Attrib_SetRefundableCurrency(Address pAttrib, int nCurrency);

/**
 * Returns the value of m_nRefundableCurrency on an attribute.
 *
 * @param pAttrib		Address of the attribute.
 *
 * @return				The (unsigned) integer value of m_nRefundableCurrency on the attribute.
 */
native int TF2Attrib_GetRefundableCurrency(Address pAttrib);

/**
 * Returns an array containing the attributes (as indices) present on an entity.
 *
 * @param iEntity		Entity index to get attribute list from. Must have m_AttributeList.
 * @param iDefIndices	Array of attribute definition indices found on the entity.
 * @param iMaxLen		Max length of the iDefIndices array, default 20. Does not affect the return value.
 *
 * @return				The number of attributes found on the entity's attribute list (max 20 as of Oct 2017), or -1 if some error happened.
 * @error				Invalid iEntity or iMaxLen.
 */
native int TF2Attrib_ListDefIndices(int iEntity, int[] iDefIndices, int iMaxLen=20);

/**
 * Returns arrays containing the static attributes and their values present on an item definition.
 *
 * @param iItemDefIndex		Item definition index (e.g. 7 for Shovel) to get static attribute list from.
 * @param iAttribIndices	Array of attribute definition indices found on the item definition.
 * @param flAttribValues	Array of attribute values found on the item definition, corresponding to the indices.
 * @param iMaxLen			Max length of the two arrays passed in, default 16. Does not affect the return value.
 *
 * @return					The number of attributes found on the item definition's static attribute list (max 16 as of June 2017), or -1 if no schema or item definition found.
 * @error					Invalid iMaxLen, or gamedata for this function failed to load.
 */
native int TF2Attrib_GetStaticAttribs(int iItemDefIndex, int[] iAttribIndices, float[] flAttribValues, int iMaxLen=16);

/**
 * Returns arrays containing the item server (SOC) attributes and their values present on an item definition.
 *
 * @param iEntity			Entity index to get the item server attribute list from.
 * @param iAttribIndices	Array of attribute definition indices found.
 * @param flAttribValues	Array of attribute values found, corresponding to the indices.
 * @param iMaxLen			Max length of the two arrays passed in, default 16. Does not affect the return value.
 *
 * @return					The number of attributes found on the item's SOC attribute list (max 16 as of June 2017), or -1 if some error happened.
 * @error					Invalid iEntity or iMaxLen, or gamedata for this function failed to load.
 */
native int TF2Attrib_GetSOCAttribs(int iEntity, int[] iAttribIndices, float[] flAttribValues, int iMaxLen=16);

/**
 * Gets whether an attribute is stored as an integer or as a float.
 * Use TF2Attrib_SetValue(attribute, view_as<float>(intValue)) on attributes that store values as ints
 *   to avoid compiler tag mismatch warnings.
 *
 * @param iDefIndex		Index of the attribute (as returned by TF2Attrib_GetDefIndex()).
 *
 * @return				True if attribute value is supposed to be an int, false if float.
 */
native bool TF2Attrib_IsIntegerValue(int iDefIndex);

/**
 * Returns true if an attribute with the specified name exists.
 *
 * @param strAttrib			Name of the attribute, as from the "name" key in items_game.
 *
 * @return					True if the attribute exists, false otherwise.
 */
native bool TF2Attrib_IsValidAttributeName(const char[] strAttrib);

/** 
 * Adds a custom, potentially temporary attribute to a player.
 * 
 * @param client			Client index to set the attribute on.
 * @param strAttrib			Name of the attribute, as from the "name" key in items_game.
 * @param flValue			Value to set m_flValue to.
 * @param flDuration		Duration of the attribute.  If less than 0, the attribute will not be automatically removed.
 * 
 * @noreturn
 */
native void TF2Attrib_AddCustomPlayerAttribute(int client, const char[] strAttrib, float flValue, float flDuration = -1.0);

/**
 * Removes a previously applied custom attribute on a player.
 *
 * @param client			Client index to remove the attribute from.
 * @param strAttrib			Name of the attribute, as from the "name" key in items_game.
 *
 * @noreturn
 */
native void TF2Attrib_RemoveCustomPlayerAttribute(int client, const char[] strAttrib);

/**
 * Applies a transformation to the given initial value, following the rules according to the given attribute class.
 * 
 * @param flInitial			Initial float value.
 * @param attrClass			The attribute class, as from the "attribute_class" key in items_game.
 * @param iEntity			The entity that should be checked.  Checking players also checks their equipped items.
 * 
 * @return					Transformed initial value.
 */
native float TF2Attrib_HookValueFloat(float flInitial, const char[] attrClass, int iEntity);

/**
 * Applies a transformation to the given initial value, following the rules according to the given attribute class.
 * 
 * @param nInitial			Initial integer value.
 * @param attrClass			The attribute class, as from the "attribute_class" key in items_game.
 * @param iEntity			The entity that should be checked.  Checking players also checks their equipped items.
 * 
 * @return					Transformed initial value.
 */
native int TF2Attrib_HookValueInt(int nInitial, const char[] attrClass, int iEntity);

/**
 * Applies a transformation to the given initial value, following the rules according to the given attribute class.
 * 
 * @param initial			Initial string value.  (This appears to only be returned if the entity doesn't have the attribute.)
 * @param attrClass			The attribute class, as from the "attribute_class" key in items_game.
 * @param iEntity			The entity that should be checked.  Checking players also checks their equipped items.
 * @param buffer			Transformed initial value.
 * @param maxlen			Buffer size.
 * 
 * @return					Number of bytes written.
 */
native int TF2Attrib_HookValueString(const char[] initial, const char[] attrClass, int iEntity, char[] buffer, int maxlen);

/**
 * Gets whether the plugin loaded without ANY errors.
 * For the purpose of allowing dependencies to ignore the plugin if this returns false.
 * Check in OnAllPluginsLoaded() or something. I dunno.
 *
 * @return				True if no errors while loading, false otherwise.
 */
native bool TF2Attrib_IsReady();

public SharedPlugin __pl_tf2attributes =
{
	name = "tf2attributes",
	file = "tf2attributes.smx",
#if defined REQUIRE_PLUGIN
	required = 1,
#else
	required = 0,
#endif
};

#if !defined REQUIRE_PLUGIN
public void __pl_tf2attributes_SetNTVOptional()
{
	MarkNativeAsOptional("TF2Attrib_SetByName");
	MarkNativeAsOptional("TF2Attrib_SetByDefIndex");
	MarkNativeAsOptional("TF2Attrib_GetByName");
	MarkNativeAsOptional("TF2Attrib_GetByDefIndex");
	MarkNativeAsOptional("TF2Attrib_RemoveByName");
	MarkNativeAsOptional("TF2Attrib_RemoveByDefIndex");
	MarkNativeAsOptional("TF2Attrib_RemoveAll");
	MarkNativeAsOptional("TF2Attrib_ClearCache");
	MarkNativeAsOptional("TF2Attrib_SetDefIndex");
	MarkNativeAsOptional("TF2Attrib_GetDefIndex");
	MarkNativeAsOptional("TF2Attrib_SetValue");
	MarkNativeAsOptional("TF2Attrib_GetValue");
	MarkNativeAsOptional("TF2Attrib_SetRefundableCurrency");
	MarkNativeAsOptional("TF2Attrib_GetRefundableCurrency");
	MarkNativeAsOptional("TF2Attrib_ListDefIndices");
	MarkNativeAsOptional("TF2Attrib_GetStaticAttribs");
	MarkNativeAsOptional("TF2Attrib_GetSOCAttribs");
	MarkNativeAsOptional("TF2Attrib_ListDefIndices");
	MarkNativeAsOptional("TF2Attrib_IsIntegerValue");
	MarkNativeAsOptional("TF2Attrib_IsValidAttributeName");
	MarkNativeAsOptional("TF2Attrib_AddCustomPlayerAttribute");
	MarkNativeAsOptional("TF2Attrib_RemoveCustomPlayerAttribute");
	MarkNativeAsOptional("TF2Attrib_HookValueFloat");
	MarkNativeAsOptional("TF2Attrib_HookValueInt");
	
	MarkNativeAsOptional("TF2Attrib_IsReady");
}
#endif

tf2_stocks:
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _tf2_stocks_included
 #endinput
#endif
#define _tf2_stocks_included

#include <tf2>
#include <sdktools>

#define TF_CONDFLAG_NONE            0
#define TF_CONDFLAG_SLOWED          (1 << 0)
#define TF_CONDFLAG_ZOOMED          (1 << 1)
#define TF_CONDFLAG_DISGUISING      (1 << 2)
#define TF_CONDFLAG_DISGUISED       (1 << 3)
#define TF_CONDFLAG_CLOAKED         (1 << 4)
#define TF_CONDFLAG_UBERCHARGED     (1 << 5)
#define TF_CONDFLAG_TELEPORTGLOW    (1 << 6)
#define TF_CONDFLAG_TAUNTING        (1 << 7)
#define TF_CONDFLAG_UBERCHARGEFADE  (1 << 8)
#define TF_CONDFLAG_CLOAKFLICKER    (1 << 9)
#define TF_CONDFLAG_TELEPORTING     (1 << 10)
#define TF_CONDFLAG_KRITZKRIEGED    (1 << 11)
#define TF_CONDFLAG_DEADRINGERED    (1 << 13)
#define TF_CONDFLAG_BONKED          (1 << 14)
#define TF_CONDFLAG_DAZED           (1 << 15)
#define TF_CONDFLAG_BUFFED          (1 << 16)
#define TF_CONDFLAG_CHARGING        (1 << 17)
#define TF_CONDFLAG_DEMOBUFF        (1 << 18)
#define TF_CONDFLAG_CRITCOLA        (1 << 19)
#define TF_CONDFLAG_INHEALRADIUS    (1 << 20)
#define TF_CONDFLAG_HEALING         (1 << 21)
#define TF_CONDFLAG_ONFIRE          (1 << 22)
#define TF_CONDFLAG_OVERHEALED      (1 << 23)
#define TF_CONDFLAG_JARATED         (1 << 24)
#define TF_CONDFLAG_BLEEDING        (1 << 25)
#define TF_CONDFLAG_DEFENSEBUFFED   (1 << 26)
#define TF_CONDFLAG_MILKED          (1 << 27)
#define TF_CONDFLAG_MEGAHEAL        (1 << 28)
#define TF_CONDFLAG_REGENBUFFED     (1 << 29)
#define TF_CONDFLAG_MARKEDFORDEATH  (1 << 30)

#define TF_DEATHFLAG_KILLERDOMINATION   (1 << 0)
#define TF_DEATHFLAG_ASSISTERDOMINATION (1 << 1)
#define TF_DEATHFLAG_KILLERREVENGE      (1 << 2)
#define TF_DEATHFLAG_ASSISTERREVENGE    (1 << 3)
#define TF_DEATHFLAG_FIRSTBLOOD         (1 << 4)
#define TF_DEATHFLAG_DEADRINGER         (1 << 5)
#define TF_DEATHFLAG_INTERRUPTED        (1 << 6)
#define TF_DEATHFLAG_GIBBED             (1 << 7)
#define TF_DEATHFLAG_PURGATORY          (1 << 8)
#define TF_DEATHFLAG_MINIBOSS           (1 << 9)
#define TF_DEATHFLAG_AUSTRALIUM         (1 << 10)

// Custom kill identifiers for the customkill property on the player_death event
enum {
	TF_CUSTOM_HEADSHOT = 1,
	TF_CUSTOM_BACKSTAB,
	TF_CUSTOM_BURNING,
	TF_CUSTOM_WRENCH_FIX,
	TF_CUSTOM_MINIGUN,
	TF_CUSTOM_SUICIDE,
	TF_CUSTOM_TAUNT_HADOUKEN,
	TF_CUSTOM_BURNING_FLARE,
	TF_CUSTOM_TAUNT_HIGH_NOON,
	TF_CUSTOM_TAUNT_GRAND_SLAM,
	TF_CUSTOM_PENETRATE_MY_TEAM,
	TF_CUSTOM_PENETRATE_ALL_PLAYERS,
	TF_CUSTOM_TAUNT_FENCING,
	TF_CUSTOM_PENETRATE_HEADSHOT,
	TF_CUSTOM_TAUNT_ARROW_STAB,
	TF_CUSTOM_TELEFRAG,
	TF_CUSTOM_BURNING_ARROW,
	TF_CUSTOM_FLYINGBURN,
	TF_CUSTOM_PUMPKIN_BOMB,
	TF_CUSTOM_DECAPITATION,
	TF_CUSTOM_TAUNT_GRENADE,
	TF_CUSTOM_BASEBALL,
	TF_CUSTOM_CHARGE_IMPACT,
	TF_CUSTOM_TAUNT_BARBARIAN_SWING,
	TF_CUSTOM_AIR_STICKY_BURST,
	TF_CUSTOM_DEFENSIVE_STICKY,
	TF_CUSTOM_PICKAXE,
	TF_CUSTOM_ROCKET_DIRECTHIT,
	TF_CUSTOM_TAUNT_UBERSLICE,
	TF_CUSTOM_PLAYER_SENTRY,
	TF_CUSTOM_STANDARD_STICKY,
	TF_CUSTOM_SHOTGUN_REVENGE_CRIT,
	TF_CUSTOM_TAUNT_ENGINEER_SMASH,
	TF_CUSTOM_BLEEDING,
	TF_CUSTOM_GOLD_WRENCH,
	TF_CUSTOM_CARRIED_BUILDING,
	TF_CUSTOM_COMBO_PUNCH,
	TF_CUSTOM_TAUNT_ENGINEER_ARM,
	TF_CUSTOM_FISH_KILL,
	TF_CUSTOM_TRIGGER_HURT,
	TF_CUSTOM_DECAPITATION_BOSS,
	TF_CUSTOM_STICKBOMB_EXPLOSION,
	TF_CUSTOM_AEGIS_ROUND,
	TF_CUSTOM_FLARE_EXPLOSION,
	TF_CUSTOM_BOOTS_STOMP,
	TF_CUSTOM_PLASMA,
	TF_CUSTOM_PLASMA_CHARGED,
	TF_CUSTOM_PLASMA_GIB,
	TF_CUSTOM_PRACTICE_STICKY,
	TF_CUSTOM_EYEBALL_ROCKET,
	TF_CUSTOM_HEADSHOT_DECAPITATION,
	TF_CUSTOM_TAUNT_ARMAGEDDON,
	TF_CUSTOM_FLARE_PELLET,
	TF_CUSTOM_CLEAVER,
	TF_CUSTOM_CLEAVER_CRIT,
	TF_CUSTOM_SAPPER_RECORDER_DEATH,
	TF_CUSTOM_MERASMUS_PLAYER_BOMB,
	TF_CUSTOM_MERASMUS_GRENADE,
	TF_CUSTOM_MERASMUS_ZAP,
	TF_CUSTOM_MERASMUS_DECAPITATION,
	TF_CUSTOM_CANNONBALL_PUSH,
	TF_CUSTOM_TAUNT_ALLCLASS_GUITAR_RIFF,
	TF_CUSTOM_THROWABLE,
	TF_CUSTOM_THROWABLE_KILL,
	TF_CUSTOM_SPELL_TELEPORT,
	TF_CUSTOM_SPELL_SKELETON,
	TF_CUSTOM_SPELL_MIRV,
	TF_CUSTOM_SPELL_METEOR,
	TF_CUSTOM_SPELL_LIGHTNING,
	TF_CUSTOM_SPELL_FIREBALL,
	TF_CUSTOM_SPELL_MONOCULUS,
	TF_CUSTOM_SPELL_BLASTJUMP,
	TF_CUSTOM_SPELL_BATS,
	TF_CUSTOM_SPELL_TINY,
	TF_CUSTOM_KART,
	TF_CUSTOM_GIANT_HAMMER,
	TF_CUSTOM_RUNE_REFLECT,
	TF_CUSTOM_DRAGONS_FURY_IGNITE,
	TF_CUSTOM_DRAGONS_FURY_BONUS_BURNING,
	TF_CUSTOM_SLAP_KILL,
	TF_CUSTOM_CROC,
	TF_CUSTOM_TAUNTATK_GASBLAST,
	TF_CUSTOM_AXTINGUISHER_BOOSTED
};

// Weapon codes as used in some events, such as player_death
// (not to be confused with Item Definition Indexes)
enum {
	TF_WEAPON_NONE = 0,
	TF_WEAPON_BAT,
	TF_WEAPON_BAT_WOOD,
	TF_WEAPON_BOTTLE,
	TF_WEAPON_FIREAXE,
	TF_WEAPON_CLUB,
	TF_WEAPON_CROWBAR,
	TF_WEAPON_KNIFE,
	TF_WEAPON_FISTS,
	TF_WEAPON_SHOVEL,
	TF_WEAPON_WRENCH,
	TF_WEAPON_BONESAW,
	TF_WEAPON_SHOTGUN_PRIMARY,
	TF_WEAPON_SHOTGUN_SOLDIER,
	TF_WEAPON_SHOTGUN_HWG,
	TF_WEAPON_SHOTGUN_PYRO,
	TF_WEAPON_SCATTERGUN,
	TF_WEAPON_SNIPERRIFLE,
	TF_WEAPON_MINIGUN,
	TF_WEAPON_SMG,
	TF_WEAPON_SYRINGEGUN_MEDIC,
	TF_WEAPON_TRANQ,
	TF_WEAPON_ROCKETLAUNCHER,
	TF_WEAPON_GRENADELAUNCHER,
	TF_WEAPON_PIPEBOMBLAUNCHER,
	TF_WEAPON_FLAMETHROWER,
	TF_WEAPON_GRENADE_NORMAL,
	TF_WEAPON_GRENADE_CONCUSSION,
	TF_WEAPON_GRENADE_NAIL,
	TF_WEAPON_GRENADE_MIRV,
	TF_WEAPON_GRENADE_MIRV_DEMOMAN,
	TF_WEAPON_GRENADE_NAPALM,
	TF_WEAPON_GRENADE_GAS,
	TF_WEAPON_GRENADE_EMP,
	TF_WEAPON_GRENADE_CALTROP,
	TF_WEAPON_GRENADE_PIPEBOMB,
	TF_WEAPON_GRENADE_SMOKE_BOMB,
	TF_WEAPON_GRENADE_HEAL,
	TF_WEAPON_GRENADE_STUNBALL,
	TF_WEAPON_GRENADE_JAR,
	TF_WEAPON_GRENADE_JAR_MILK,
	TF_WEAPON_PISTOL,
	TF_WEAPON_PISTOL_SCOUT,
	TF_WEAPON_REVOLVER,
	TF_WEAPON_NAILGUN,
	TF_WEAPON_PDA,
	TF_WEAPON_PDA_ENGINEER_BUILD,
	TF_WEAPON_PDA_ENGINEER_DESTROY,
	TF_WEAPON_PDA_SPY,
	TF_WEAPON_BUILDER,
	TF_WEAPON_MEDIGUN,
	TF_WEAPON_GRENADE_MIRVBOMB,
	TF_WEAPON_FLAMETHROWER_ROCKET,
	TF_WEAPON_GRENADE_DEMOMAN,
	TF_WEAPON_SENTRY_BULLET,
	TF_WEAPON_SENTRY_ROCKET,
	TF_WEAPON_DISPENSER,
	TF_WEAPON_INVIS,
	TF_WEAPON_FLAREGUN,
	TF_WEAPON_LUNCHBOX,
	TF_WEAPON_JAR,
	TF_WEAPON_COMPOUND_BOW,
	TF_WEAPON_BUFF_ITEM,
	TF_WEAPON_PUMPKIN_BOMB,
	TF_WEAPON_SWORD,
	TF_WEAPON_DIRECTHIT,
	TF_WEAPON_LIFELINE,
	TF_WEAPON_LASER_POINTER,
	TF_WEAPON_DISPENSER_GUN,
	TF_WEAPON_SENTRY_REVENGE,
	TF_WEAPON_JAR_MILK,
	TF_WEAPON_HANDGUN_SCOUT_PRIMARY,
	TF_WEAPON_BAT_FISH,
	TF_WEAPON_CROSSBOW,
	TF_WEAPON_STICKBOMB,
	TF_WEAPON_HANDGUN_SCOUT_SEC,
	TF_WEAPON_SODA_POPPER,
	TF_WEAPON_SNIPERRIFLE_DECAP,
	TF_WEAPON_RAYGUN,
	TF_WEAPON_PARTICLE_CANNON,
	TF_WEAPON_MECHANICAL_ARM,
	TF_WEAPON_DRG_POMSON,
	TF_WEAPON_BAT_GIFTWRAP,
	TF_WEAPON_GRENADE_ORNAMENT,
	TF_WEAPON_RAYGUN_REVENGE,
	TF_WEAPON_PEP_BRAWLER_BLASTER,
	TF_WEAPON_CLEAVER,
	TF_WEAPON_GRENADE_CLEAVER,
	TF_WEAPON_STICKY_BALL_LAUNCHER,
	TF_WEAPON_GRENADE_STICKY_BALL,
	TF_WEAPON_SHOTGUN_BUILDING_RESCUE,
	TF_WEAPON_CANNON,
	TF_WEAPON_THROWABLE,
	TF_WEAPON_GRENADE_THROWABLE,
	TF_WEAPON_PDA_SPY_BUILD,
	TF_WEAPON_GRENADE_WATERBALLOON,
	TF_WEAPON_HARVESTER_SAW,
	TF_WEAPON_SPELLBOOK,
	TF_WEAPON_SPELLBOOK_PROJECTILE,
	TF_WEAPON_SNIPERRIFLE_CLASSIC,
	TF_WEAPON_PARACHUTE,
	TF_WEAPON_GRAPPLINGHOOK,
	TF_WEAPON_PASSTIME_GUN,
	TF_WEAPON_CHARGED_SMG,
	TF_WEAPON_BREAKABLE_SIGN,
	TF_WEAPON_ROCKETPACK,
	TF_WEAPON_SLAP,
	TF_WEAPON_JAR_GAS,
	TF_WEAPON_GRENADE_JAR_GAS,
	TF_WEAPON_FLAME_BALL
};

// TF2 Weapon Loadout Slots
enum
{
	TFWeaponSlot_Primary,
	TFWeaponSlot_Secondary,
	TFWeaponSlot_Melee,
	TFWeaponSlot_Grenade,
	TFWeaponSlot_Building,
	TFWeaponSlot_PDA,
	TFWeaponSlot_Item1,
	TFWeaponSlot_Item2
};

// Identifiers for the eventtype property on the teamplay_flag_event event
enum {
	TF_FLAGEVENT_PICKEDUP = 1,
	TF_FLAGEVENT_CAPTURED,
	TF_FLAGEVENT_DEFENDED,
	TF_FLAGEVENT_DROPPED,
	TF_FLAGEVENT_RETURNED
};

enum TFResourceType
{
	TFResource_Ping,
	TFResource_Score,
	TFResource_Deaths,
	TFResource_TotalScore,
	TFResource_Captures,
	TFResource_Defenses,
	TFResource_Dominations,
	TFResource_Revenge,
	TFResource_BuildingsDestroyed,
	TFResource_Headshots,
	TFResource_Backstabs,
	TFResource_HealPoints,
	TFResource_Invulns,
	TFResource_Teleports,
	TFResource_ResupplyPoints,
	TFResource_KillAssists,
	TFResource_MaxHealth,
	TFResource_PlayerClass
};

static const char TFResourceNames[][] =
{
	"m_iPing",
	"m_iScore",
	"m_iDeaths",
	"m_iTotalScore",
	"m_iCaptures",
	"m_iDefenses",
	"m_iDominations",
	"m_iRevenge",
	"m_iBuildingsDestroyed",
	"m_iHeadshots",
	"m_iBackstabs",
	"m_iHealPoints",
	"m_iInvulns",
	"m_iTeleports",
	"m_iResupplyPoints",
	"m_iKillAssists",
	"m_iMaxHealth",
	"m_iPlayerClass"
};

/**
 * Gets a client's current team.
 *
 * @param client        Client index.
 * @return              Current TFTeam of client.
 * @error               Invalid client index.
 */
stock TFTeam TF2_GetClientTeam(int client)
{
	return view_as<TFTeam>(GetClientTeam(client));
}

/**
 * Changes a client's current team.
 *
 * @param client        Client index.
 * @param team          TFTeam team symbol.
 * @error               Invalid client index.
 */
stock void TF2_ChangeClientTeam(int client, TFTeam team)
{
    ChangeClientTeam(client, view_as<int>(team));
}

/**
 * Gets a client's current class.
 *
 * @param client        Player's index.
 * @return              Current TFClassType of player.
 * @error               Invalid client index.
 */
stock TFClassType TF2_GetPlayerClass(int client)
{
	return view_as<TFClassType>(GetEntProp(client, Prop_Send, "m_iClass"));
}

/**
 * Sets a client's class.
 *
 * Note: If setting player class in a player spawn hook weapons should be set to false.
 *
 * @param client        Player's index.
 * @param classType     TFClassType class symbol.
 * @param weapons       This parameter is ignored.
 * @param persistent    If true, changes the player's desired class so the change stays after death.
 * @error               Invalid client index.
 */
stock void TF2_SetPlayerClass(int client, TFClassType classType, bool weapons=true, bool persistent=true)
{
	#pragma unused weapons
	SetEntProp(client, Prop_Send, "m_iClass", view_as<int>(classType));

	if (persistent)
	{
		SetEntProp(client, Prop_Send, "m_iDesiredPlayerClass", view_as<int>(classType));
	}
}

/**
 * Retrieves client data from the resource entity
 *
 * @param client		Player's index.
 * @param type			ResourceType constant
 * @return				Value or -1 on failure.
 * @error				Invalid client index, client not in game or failed to find resource entity.
 * @deprecated          Use GetPlayerResourceEntity and GetEntProp instead.
 */
#pragma deprecated Use GetPlayerResourceEntity and GetEntProp instead
stock int TF2_GetPlayerResourceData(int client, TFResourceType type)
{
	if (!IsClientConnected(client))
	{
		return -1;
	}

	int offset = FindSendPropInfo("CTFPlayerResource", TFResourceNames[type]);

	if (offset < 1)
	{
		return -1;
	}

	int entity = GetPlayerResourceEntity();

	if (entity == -1)
	{
		return -1;
	}

	return GetEntData(entity, offset + (client*4));
}

/**
 * Sets client data in the resource entity
 *
 * Note: The game overwrites these values every frame, so changing them will have very little effect.
 *
 * @param client        Player's index.
 * @param type          ResourceType constant
 * @param value         Value to set.
 * @return              Value or -1 on failure.
 * @error               Invalid client index, client not in game or failed to find resource entity.
 * @deprecated          Use GetPlayerResourceEntity and SetEntProp instead.
 */
#pragma deprecated Use GetPlayerResourceEntity and SetEntProp instead
stock bool TF2_SetPlayerResourceData(int client, TFResourceType type, any value)
{
	if (!IsClientConnected(client))
	{
		return false;
	}

	int offset = FindSendPropInfo("CTFPlayerResource", TFResourceNames[type]);

	if (offset < 1)
	{
		return false;
	}

	int entity = GetPlayerResourceEntity();

	if (entity == -1)
	{
		return false;
	}

	SetEntData(entity, offset + (client*4), value);

	return true;
}

/**
 * Removes all weapons from a client's weapon slot
 *
 * @param client        Player's index.
 * @param slot          Slot index (0-5)
 * @error               Invalid client, invalid slot or lack of mod support
 */
stock void TF2_RemoveWeaponSlot(int client, int slot)
{
	int weaponIndex;
	while ((weaponIndex = GetPlayerWeaponSlot(client, slot)) != -1)
	{
		// bug #6206
		// papering over a valve bug where a weapon's extra wearables aren't properly removed from the weapon's owner
		int extraWearable = GetEntPropEnt(weaponIndex, Prop_Send, "m_hExtraWearable");
		if (extraWearable != -1)
		{
			TF2_RemoveWearable(client, extraWearable);
		}

		extraWearable = GetEntPropEnt(weaponIndex, Prop_Send, "m_hExtraWearableViewModel");
		if (extraWearable != -1)
		{
			TF2_RemoveWearable(client, extraWearable);
		}

		RemovePlayerItem(client, weaponIndex);
		AcceptEntityInput(weaponIndex, "Kill");
	}
}

/**
 * Removes all weapons from a client
 *
 * @param client        Player's index.
 */
stock void TF2_RemoveAllWeapons(int client)
{
	for (int i = 0; i <= 5; i++)
	{
		TF2_RemoveWeaponSlot(client, i);
	}
}

/**
 * Gets a player's condition bits
 *
 * @param client        Player's index.
 * @return              Player's condition bits
 * @deprecated          Use TF2_IsPlayerInCondition instead.
 */
#pragma deprecated Use TF2_IsPlayerInCondition instead.
stock int TF2_GetPlayerConditionFlags(int client)
{
	return GetEntProp(client, Prop_Send, "m_nPlayerCond")|GetEntProp(client, Prop_Send, "_condition_bits");
}

/**
 * Check whether or not a condition is set on a player
 *
 * @param client        Player's index.
 * @param cond          TFCond constant
 * @return              True if set, false otherwise
 */
stock bool TF2_IsPlayerInCondition(int client, TFCond cond)
{
	// Conditions are stored across multiple netprops now, one for each 32-bit segment.
	int iCond = view_as<int>(cond);
	switch (iCond / 32)
	{
		case 0:
		{
			int bit = 1 << iCond;
			if ((GetEntProp(client, Prop_Send, "m_nPlayerCond") & bit) == bit)
			{
				return true;
			}

			if ((GetEntProp(client, Prop_Send, "_condition_bits") & bit) == bit)
			{
				return true;
			}
		}
		case 1:
		{
			int bit = (1 << (iCond - 32));
			if ((GetEntProp(client, Prop_Send, "m_nPlayerCondEx") & bit) == bit)
			{
				return true;
			}
		}
		case 2:
		{
			int bit = (1 << (iCond - 64));
			if ((GetEntProp(client, Prop_Send, "m_nPlayerCondEx2") & bit) == bit)
			{
				return true;
			}
		}
		case 3:
		{
			int bit = (1 << (iCond - 96));
			if ((GetEntProp(client, Prop_Send, "m_nPlayerCondEx3") & bit) == bit)
			{
				return true;
			}
		}
		case 4:
		{
			int bit = (1 << (iCond - 128));
			if ((GetEntProp(client, Prop_Send, "m_nPlayerCondEx4") & bit) == bit)
			{
				return true;
			}
		}
		default:
		{
			ThrowError("Invalid TFCond value %d", iCond);
		}
	}

	return false;
}

/**
 * Gets an entity's object type.
 *
 * @param entity        Entity index.
 * @return              Current TFObjectType of entity.
 * @error               Invalid entity index.
 */
stock TFObjectType TF2_GetObjectType(int entity)
{
	int offset = GetEntSendPropOffs(entity, "m_iObjectType");

	if (offset <= 0)
	{
		ThrowError("Entity index %d is not an object", entity);
	}

	return view_as<TFObjectType>(GetEntData(entity, offset));
}

/**
 * Gets an entity's object mode.
 *
 * @param entity        Entity index.
 * @return              Current TFObjectMode of entity.
 * @error               Invalid entity index.
 */
stock TFObjectMode TF2_GetObjectMode(int entity)
{
	int offset = GetEntSendPropOffs(entity, "m_iObjectMode");

	if (offset <= 0)
	{
		ThrowError("Entity index %d is not an object", entity);
	}

	return view_as<TFObjectMode>(GetEntData(entity, offset));
}


sourcemod:
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _sourcemod_included
 #endinput
#endif
#define _sourcemod_included

/**
 * Plugin public information.
 */
struct Plugin
{
   public const char[] name;        /**< Plugin Name */
   public const char[] description; /**< Plugin Description */
   public const char[] author;      /**< Plugin Author */
   public const char[] version;     /**< Plugin Version */
   public const char[] url;         /**< Plugin URL */
};

#include <core>
#include <float>
#include <vector>
#include <string>
#include <handles>
#include <functions>
#include <files>
#include <logging>
#include <timers>
#include <admin>
#include <keyvalues>
#include <dbi>
#include <lang>
#include <sorting>
#include <textparse>
#include <clients>
#include <console>
#include <convars>
#include <events>
#include <bitbuffer>
#include <protobuf>
#include <usermessages>
#include <menus>
#include <halflife>
#include <adt>
#include <banning>
#include <commandfilters>
#include <nextmap>
#include <commandline>
#include <entitylump>

enum APLRes
{
	APLRes_Success = 0,     /**< Plugin should load */
	APLRes_Failure,         /**< Plugin shouldn't load and should display an error */
	APLRes_SilentFailure    /**< Plugin shouldn't load but do so silently */
};

methodmap GameData < Handle
{
	// Loads a game config file.
	//
	// @param file          File to load.  The path must be relative to the 'gamedata' folder under the config folder
	//                      and the extension should be omitted.
	// @return              A handle to the game config file or null on failure.
	public native GameData(const char[] file);

	// Returns an offset value.
	//
	// @param key           Key to retrieve from the offset section.
	// @return              An offset, or -1 on failure.
	public native int GetOffset(const char[] key);

	// Gets the value of a key from the "Keys" section.
	//
	// @param key           Key to retrieve from the Keys section.
	// @param buffer        Destination string buffer.
	// @param maxlen        Maximum length of output string buffer.
	// @return              True if key existed, false otherwise.
	public native bool GetKeyValue(const char[] key, char[] buffer, int maxlen);

	// Finds an address calculation in a GameConfig file,
	// performs LoadFromAddress on it as appropriate, then returns the final address.
	//
	// @param name          Name of the property to find.
	// @return              An address calculated on success, or 0 on failure.
	public native Address GetAddress(const char[] name);

	// Returns a function address calculated from a signature.
	//
	// @param name          Name of the property to find.
	// @return              An address calculated on success, or 0 on failure.
	public native Address GetMemSig(const char[] name);
};

/**
 * Called when the plugin is fully initialized and all known external references
 * are resolved. This is only called once in the lifetime of the plugin, and is
 * paired with OnPluginEnd().
 *
 * If any run-time error is thrown during this callback, the plugin will be marked
 * as failed.
 */
forward void OnPluginStart();

/**
 * @deprecated Use AskPluginLoad2() instead.
 * If a plugin contains both AskPluginLoad() and AskPluginLoad2(), the former will
 * not be called, but old plugins with only AskPluginLoad() will work.
 */
#pragma deprecated Use AskPluginLoad2() instead
forward bool AskPluginLoad(Handle myself, bool late, char[] error, int err_max);

/**
 * Called before OnPluginStart, in case the plugin wants to check for load failure.
 * This is called even if the plugin type is "private."  Any natives from modules are
 * not available at this point.  Thus, this forward should only be used for explicit
 * pre-emptive things, such as adding dynamic natives, setting certain types of load
 * filters (such as not loading the plugin for certain games).
 *
 * @note It is not safe to call externally resolved natives until OnPluginStart().
 * @note Any sort of RTE in this function will cause the plugin to fail loading.
 * @note If you do not return anything, it is treated like returning success.
 * @note If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called.
 *
 * @param myself        Handle to the plugin.
 * @param late          Whether or not the plugin was loaded "late" (after map load).
 * @param error         Error message buffer in case load failed.
 * @param err_max       Maximum number of characters for error message buffer.
 * @return              APLRes_Success for load success, APLRes_Failure or APLRes_SilentFailure otherwise
 */
forward APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int err_max);

/**
 * Called when the plugin is about to be unloaded.
 *
 * It is not necessary to close any handles or remove hooks in this function.
 * SourceMod guarantees that plugin shutdown automatically and correctly releases
 * all resources.
 */
forward void OnPluginEnd();

/**
 * Called when the plugin's pause status is changing.
 *
 * @param pause         True if the plugin is being paused, false otherwise.
 */
forward void OnPluginPauseChange(bool pause);

/**
 * Called before every server frame.  Note that you should avoid
 * doing expensive computations or declaring large local arrays.
 */
forward void OnGameFrame();

/**
 * Called when the map starts loading.
 *
 * @param mapName Name of the map
 */
forward void OnMapInit(const char[] mapName);

/**
 * Called when the map is loaded.
 */
forward void OnMapStart();

/**
 * Called right before a map ends.
 */
forward void OnMapEnd();

/**
 * Called when the map has loaded, servercfgfile (server.cfg) has been
 * executed, and all plugin configs are done executing.  This is the best
 * place to initialize plugin functions which are based on cvar data.
 *
 * @note This will always be called once and only once per map.  It will be
 *       called after OnMapStart().
 */
forward void OnConfigsExecuted();

/**
 * This is called once, right after OnMapStart() but any time before
 * OnConfigsExecuted().  It is called after the "exec sourcemod.cfg"
 * command and all AutoExecConfig() exec commands have been added to
 * the ServerCommand() buffer.
 *
 * If you need to load per-map settings that override default values,
 * adding commands to the ServerCommand() buffer here will guarantee
 * that they're set before OnConfigsExecuted().
 *
 * Unlike OnMapStart() and OnConfigsExecuted(), this is not called on
 * late loads that occur after OnMapStart().
 */
forward void OnAutoConfigsBuffered();

/**
 * @deprecated          Use OnConfigsExecuted() instead.
 */
#pragma deprecated Use OnConfigsExecuted() instead
forward void OnServerCfg();

/**
 * Called after all plugins have been loaded.  This is called once for
 * every plugin.  If a plugin late loads, it will be called immediately
 * after OnPluginStart().
 */
forward void OnAllPluginsLoaded();

/**
 * Returns the calling plugin's Handle.
 *
 * @return              Handle of the calling plugin.
 */
native Handle GetMyHandle();

methodmap PluginIterator < Handle
{
	// Returns an iterator that can be used to search through plugins.
	//
	// @return              A new Handle to a PluginIterator.
	public native PluginIterator();

	// Advances the iterator. Returns whether there are more plugins available in the iterator.
	//
	// @return              True on more plugins, false otherwise.
	// @error               Invalid Handle.
	public native bool Next();

	// Returns the current plugin in the iterator.
	//
	// @return              Current plugin the iterator is at
	// @error               Invalid Handle.
	property Handle Plugin {
		public native get();
	}
}

/**
 * Returns an iterator that can be used to search through plugins.
 *
 * @return              Handle to iterate with.  Must be closed via
 *                      CloseHandle().
 * @error               Invalid Handle.
 */
native Handle GetPluginIterator();

/**
 * Returns whether there are more plugins available in the iterator.
 *
 * @param iter          Handle to the plugin iterator.
 * @return              True on more plugins, false otherwise.
 * @error               Invalid Handle.
 */
native bool MorePlugins(Handle iter);

/**
 * Returns the current plugin in the iterator and advances the iterator.
 *
 * @param iter          Handle to the plugin iterator.
 * @return              Current plugin the iterator is at, before
 *                      the iterator is advanced.
 * @error               Invalid Handle.
 */
native Handle ReadPlugin(Handle iter);

/**
 * Returns a plugin's status.
 *
 * @param plugin        Plugin Handle (INVALID_HANDLE uses the calling plugin).
 * @return              Status code for the plugin.
 * @error               Invalid Handle.
 */
native PluginStatus GetPluginStatus(Handle plugin);

/**
 * Retrieves a plugin's file name relative to the plugins folder.
 *
 * @param plugin        Plugin Handle (INVALID_HANDLE uses the calling plugin).
 * @param buffer        Buffer to the store the file name.
 * @param maxlength     Maximum length of the name buffer.
 * @error               Invalid Handle.
 */
native void GetPluginFilename(Handle plugin, char[] buffer, int maxlength);

/**
 * Retrieves whether or not a plugin is being debugged.
 *
 * @param plugin        Plugin Handle (INVALID_HANDLE uses the calling plugin).
 * @return              True if being debugged, false otherwise.
 * @error               Invalid Handle.
 */
native bool IsPluginDebugging(Handle plugin);

/**
 * Retrieves a plugin's public info.
 *
 * @param plugin        Plugin Handle (INVALID_HANDLE uses the calling plugin).
 * @param info          Plugin info property to retrieve.
 * @param buffer        Buffer to store info in.
 * @param maxlength     Maximum length of buffer.
 * @return              True on success, false if property is not available.
 * @error               Invalid Handle.
 */
native bool GetPluginInfo(Handle plugin, PluginInfo info, char[] buffer, int maxlength);

/**
 * Finds a plugin by its order in the list from the "plugins list" server
 * "sm" command.  You should not use this function to loop through all plugins,
 * use the iterator instead.  Looping through all plugins using this native
 * is O(n^2), whereas using the iterator is O(n).
 *
 * @param order_num     Number of the plugin as it appears in "sm plugins list".
 * @return              Plugin Handle on success, INVALID_HANDLE if no plugin
 *                      matches the given number.
 */
native Handle FindPluginByNumber(int order_num);

/**
 * Causes the plugin to enter a failed state.  An error will be thrown and
 * the plugin will be paused until it is unloaded or reloaded.
 *
 * For backwards compatibility, if no extra arguments are passed, no
 * formatting is applied.  If one or more additional arguments is passed,
 * the string is formatted using Format().  If any errors are encountered
 * during formatting, both the format specifier string and an additional
 * error message are written.
 *
 * This function does not return, and no further code in the plugin is
 * executed.
 *
 * @param string        Format specifier string.
 * @param ...           Formatting arguments.
 * @error               Always throws SP_ERROR_ABORT.
 */
native void SetFailState(const char[] string, any ...);

/**
 * Aborts the current callback and throws an error.  This function
 * does not return in that no code is executed following it.
 *
 * @param fmt           String format.
 * @param ...           Format arguments.
 * @noreturn
 * @error               Always!
 */
native void ThrowError(const char[] fmt, any ...);

/**
 * Logs a stack trace from the current function call. Code
 * execution continues after the call
 *
 * @param fmt           Format string to send with the stack trace.
 * @param ...           Format arguments.
 * @error               Always logs a stack trace.
 */
native void LogStackTrace(const char[] fmt, any ...);

/**
 * Gets the system time as a unix timestamp.
 *
 * @param bigStamp      Optional array to store the 64bit timestamp in.
 * @return              32bit timestamp (number of seconds since unix epoch).
 */
native int GetTime(int bigStamp[2]={0,0});

/**
 * Produces a date and/or time string value for a timestamp.
 *
 * See this URL for valid parameters:
 * https://cplusplus.com/reference/ctime/strftime/
 *
 * Note that available parameters depends on support from your operating system.
 * In particular, ones highlighted in yellow on that page are not currently
 * available on Windows and should be avoided for portable plugins.
 *
 * @param buffer        Destination string buffer.
 * @param maxlength     Maximum length of output string buffer.
 * @param format        Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format).
 * @param stamp         Optional time stamp.
 * @error               Buffer too small or invalid time format.
 */
native void FormatTime(char[] buffer, int maxlength, const char[] format, int stamp=-1);

/**
 * Parses a string representing a date and/or time into a unix timestamp.
 * The timezone is always interpreted as UTC/GMT.
 *
 * See this URL for valid parameters:
 * https://en.cppreference.com/w/cpp/io/manip/get_time
 *
 * Note that available parameters depends on support from your operating system.
 * In particular, ones highlighted in yellow on that page are not currently
 * available on Windows and should be avoided for portable plugins.
 *
 * @param dateTime     Date and/or time string.
 * @param format       Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format).
 * @return             32bit timestamp (number of seconds since unix epoch).
 * @error              Invalid date/time string or time format.
 */
native int ParseTime(const char[] dateTime, const char[] format);

/**
 * Loads a game config file.
 *
 * @param file          File to load.  The path must be relative to the 'gamedata' folder under the config folder
 *                      and the extension should be omitted.
 * @return              A handle to the game config file or INVALID_HANDLE on failure.
 */
native GameData LoadGameConfigFile(const char[] file);

/**
 * Returns an offset value.
 *
 * @param gc            Game config handle.
 * @param key           Key to retrieve from the offset section.
 * @return              An offset, or -1 on failure.
 */
native int GameConfGetOffset(Handle gc, const char[] key);

/**
 * Gets the value of a key from the "Keys" section.
 *
 * @param gc            Game config handle.
 * @param key           Key to retrieve from the Keys section.
 * @param buffer        Destination string buffer.
 * @param maxlen        Maximum length of output string buffer.
 * @return              True if key existed, false otherwise.
 */
native bool GameConfGetKeyValue(Handle gc, const char[] key, char[] buffer, int maxlen);

/**
 * Finds an address calculation in a GameConfig file,
 * performs LoadFromAddress on it as appropriate, then returns the final address.
 *
 * @param gameconf      Game config handle.
 * @param name          Name of the property to find.
 * @return              An address calculated on success, or 0 on failure.
 */
native Address GameConfGetAddress(Handle gameconf, const char[] name);

/**
 * Returns the operating system's "tick count," which is a number of
 * milliseconds since the operating system loaded.  This can be used
 * for basic benchmarks.
 *
 * @return              Tick count in milliseconds.
 */
native int GetSysTickCount();

/**
 * Specifies that the given config file should be executed after plugin load.
 * OnConfigsExecuted() will not be called until the config file has executed,
 * but it will be called if the execution fails.
 *
 * @param autoCreate    If true, and the config file does not exist, such a config
 *                      file will be automatically created and populated with
 *                      information from the plugin's registered cvars.
 * @param name          Name of the config file, excluding the .cfg extension.
 *                      If empty, <plugin.filename.cfg> is assumed.
 * @param folder        Folder under cfg/ to use.  By default this is "sourcemod."
 */
native void AutoExecConfig(bool autoCreate=true, const char[] name="", const char[] folder="sourcemod");

/**
 * Registers a library name for identifying as a dependency to
 * other plugins.
 *
 * @param name          Library name.
 */
native void RegPluginLibrary(const char[] name);

/**
 * Returns whether a library exists.  This function should be considered
 * expensive; it should only be called on plugin to determine availability
 * of resources.  Use OnLibraryAdded()/OnLibraryRemoved() to detect changes
 * in libraries.
 *
 * @param name          Library name of a plugin or extension.
 * @return              True if exists, false otherwise.
 */
native bool LibraryExists(const char[] name);

/**
 * Returns the status of an extension, by filename.
 *
 * @param name          Extension name (like "sdktools.ext").
 * @param error         Optional error message buffer.
 * @param maxlength     Length of optional error message buffer.
 * @return              -2 if the extension was not found.
 *                      -1 if the extension was found but failed to load.
 *                      0 if the extension loaded but reported an error.
 *                      1 if the extension is running without error.
 */
native int GetExtensionFileStatus(const char[] name, char[] error="", int maxlength=0);

/**
 * Called after a library is added.
 * A library is either a plugin name or extension name, as
 * exposed via its include file.
 *
 * @param name          Library name.
 */
forward void OnLibraryAdded(const char[] name);

/**
 * Called right before a library is removed.
 * A library is either a plugin name or extension name, as
 * exposed via its include file.
 *
 * @param name          Library name.
 */
forward void OnLibraryRemoved(const char[] name);

/**
 * Called when a plugin unloaded.
 *
 * @param plugin        Plugin Handle who unloaded.
 */
forward void OnNotifyPluginUnloaded(Handle plugin);

#define MAPLIST_FLAG_MAPSFOLDER    (1<<0)    /**< On failure, use all maps in the maps folder. */
#define MAPLIST_FLAG_CLEARARRAY    (1<<1)    /**< If an input array is specified, clear it before adding. */
#define MAPLIST_FLAG_NO_DEFAULT    (1<<2)    /**< Do not read "default" or "mapcyclefile" on failure. */

/**
 * Loads a map list to an ADT Array.
 *
 * A map list is a list of maps from a file.  SourceMod allows easy configuration of
 * maplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given a
 * name and a file (for example, "rtv" => "rtv.cfg"), or a name and a redirection
 * (for example, "rtv" => "default").  This native will read a map list entry,
 * cache the file, and return the list of maps it holds.
 *
 * Serial change numbers are used to identify if a map list has changed.  Thus, if
 * you pass a serial change number and it's equal to what SourceMod currently knows
 * about the map list, then SourceMod won't re-parse the file.
 *
 * If the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), they
 * are automatically sorted in alphabetical, ascending order.
 *
 * Arrays created by this function are temporary and must be freed via CloseHandle().
 * Modifying arrays created by this function will not affect future return values or
 * or the contents of arrays returned to other plugins.
 *
 * @param array         Array to store the map list.  If INVALID_HANDLE, a new blank
 *                      array will be created.  The blocksize should be at least 16;
 *                      otherwise results may be truncated.  Items are added to the array
 *                      as strings.  The array is never checked for duplicates, and it is
 *                      not read beforehand.  Only the serial number is used to detect
 *                      changes.
 * @param serial        Serial number to identify last known map list change.  If -1, the
 *                      the value will not be checked.  If the map list has since changed,
 *                      the serial is updated (even if -1 was passed).  If there is an error
 *                      finding a valid maplist, then the serial is set to -1.
 * @param str           Config name, or "default" for the default map list.  Config names
 *                      should be somewhat descriptive.  For example, the admin menu uses
 *                      a config name of "admin menu".  The list names can be configured
 *                      by users in addons/sourcemod/configs/maplists.cfg.
 * @param flags         MAPLIST_FLAG flags.
 * @return              On failure:
 *                      INVALID_HANDLE is returned, the serial is set to -1, and the input
 *                      array (if any) is left unchanged.
 *                      On no change:
 *                      INVALID_HANDLE is returned, the serial is unchanged, and the input
 *                      array (if any) is left unchanged.
 *                      On success:
 *                      A valid array Handle is returned, containing at least one map string.
 *                      If an array was passed, the return value is equal to the passed Array
 *                      Handle.  If the passed array was not cleared, it will have grown by at
 *                      least one item.  The serial number is updated to a positive number.
 * @error               Invalid array Handle that is not INVALID_HANDLE.
 */
native Handle ReadMapList(Handle array=INVALID_HANDLE,
                          int &serial=-1,
                          const char[] str="default",
                          int flags=MAPLIST_FLAG_CLEARARRAY);

/**
 * Makes a compatibility binding for map lists.  For example, if a function previously used
 * "clam.cfg" for map lists, this function will insert a "fake" binding to "clam.cfg" that
 * will be overridden if it's in the maplists.cfg file.
 *
 * @param name          Configuration name that would be used with ReadMapList().
 * @param file          Default file to use.
 */
native void SetMapListCompatBind(const char[] name, const char[] file);

/**
 * Called when a client has sent chat text.  This must return either true or
 * false to indicate that a client is or is not spamming the server.
 *
 * The return value is a hint only.  Core or another plugin may decide
 * otherwise.
 *
 * @param client        Client index.  The server (0) will never be passed.
 * @return              True if client is spamming the server, false otherwise.
 */
forward bool OnClientFloodCheck(int client);

/**
 * Called after a client's flood check has been computed.  This can be used
 * by antiflood algorithms to decay/increase flooding weights.
 *
 * Since the result from "OnClientFloodCheck" isn't guaranteed to be the
 * final result, it is generally a good idea to use this to play with other
 * algorithms nicely.
 *
 * @param client        Client index.  The server (0) will never be passed.
 * @param blocked       True if client flooded last "say", false otherwise.
 */
forward void OnClientFloodResult(int client, bool blocked);

/**
 * Feature types.
 */
enum FeatureType
{
	/**
	 * A native function call.
	 */
	FeatureType_Native,

	/**
	 * A named capability. This is distinctly different from checking for a
	 * native, because the underlying functionality could be enabled on-demand
	 * to improve loading time. Thus a native may appear to exist, but it might
	 * be part of a set of features that are not compatible with the current game
	 * or version of SourceMod.
	 */
	FeatureType_Capability
};

/**
 * Feature statuses.
 */
enum FeatureStatus
{
	/**
	 * Feature is available for use.
	 */
	FeatureStatus_Available,

	/**
	 * Feature is not available.
	 */
	FeatureStatus_Unavailable,

	/**
	 * Feature is not known at all.
	 */
	FeatureStatus_Unknown
};

/**
 * Returns whether "GetFeatureStatus" will work. Using this native
 * or this function will not cause SourceMod to fail loading on older versions,
 * however, GetFeatureStatus will only work if this function returns true.
 *
 * @return              True if GetFeatureStatus will work, false otherwise.
 */
stock bool CanTestFeatures()
{
	return LibraryExists("__CanTestFeatures__");
}

/**
 * Returns whether a feature exists, and if so, whether it is usable.
 *
 * @param type          Feature type.
 * @param name          Feature name.
 * @return              Feature status.
 */
native FeatureStatus GetFeatureStatus(FeatureType type, const char[] name);

/**
 * Requires that a given feature is available. If it is not, SetFailState()
 * is called with the given message.
 *
 * @param type          Feature type.
 * @param name          Feature name.
 * @param fmt           Message format string, or empty to use default.
 * @param ...           Message format parameters, if any.
 */
native void RequireFeature(FeatureType type, const char[] name,
                           const char[] fmt="", any ...);

/**
 * Represents how many bytes we can read from an address with one load
 */
enum NumberType
{
    NumberType_Int8,
    NumberType_Int16,
    NumberType_Int32
};

enum Address
{
    Address_Null = 0               // a typical invalid result when an address lookup fails
};

/**
 * Load up to 4 bytes from a memory address.
 *
 * @param addr          Address to a memory location.
 * @param size          How many bytes should be read.
 *                      If loading a floating-point value, use NumberType_Int32.
 * @return              The value that is stored at that address.
 * @error               Address is null or pointing to reserved memory.
 */
native any LoadFromAddress(Address addr, NumberType size);

/**
 * Store up to 4 bytes to a memory address.
 *
 * @param addr                     Address to a memory location.
 * @param data                     Value to store at the address.
 * @param size                     How many bytes should be written.
 *                                 If storing a floating-point value, use NumberType_Int32.
 * @param updateMemAccess          If true, SourceMod will set read / write / exec permissions
 *                                 on the memory page being written to.
 * @error                          Address is null or pointing to reserved memory.
 */
native void StoreToAddress(Address addr, any data, NumberType size, bool updateMemAccess = true);

methodmap FrameIterator < Handle {
	// Creates a stack frame iterator to build your own stack traces.
	// @return              New handle to a FrameIterator.
	public native FrameIterator();

	// Advances the iterator to the next stack frame.
	// @return              True if another frame was fetched and data can be successfully read.
	// @error               No next element exception.
	public native bool Next();

	// Resets the iterator back to it's starting position.
	public native void Reset();

	// Returns the line number of the current function call.
	property int LineNumber {
		public native get();
	}

	// Gets the name of the current function in the call stack.
	//
	// @param buffer Buffer to copy to.
	// @param maxlen Max size of the buffer.
	public native void GetFunctionName(char[] buffer, int maxlen);

	// Gets the file path to the current call in the call stack.
	//
	// @param buffer Buffer to copy to.
	// @param maxlen Max size of the buffer.
	public native void GetFilePath(char[] buffer, int maxlen);
}

#include <helpers>
#include <entity>
#include <entity_prop_stocks>]

tf2:
/**
 * vim: set ts=4 :
 * =============================================================================
 * SourceMod (C)2004-2008 AlliedModders LLC.  All rights reserved.
 * =============================================================================
 *
 * This file is part of the SourceMod/SourcePawn SDK.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License, version 3.0, as published by the
 * Free Software Foundation.
 * 
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * As a special exception, AlliedModders LLC gives you permission to link the
 * code of this program (as well as its derivative works) to "Half-Life 2," the
 * "Source Engine," the "SourcePawn JIT," and any Game MODs that run on software
 * by the Valve Corporation.  You must obey the GNU General Public License in
 * all respects for all other code used.  Additionally, AlliedModders LLC grants
 * this exception to all derivative works.  AlliedModders LLC defines further
 * exceptions, found in LICENSE.txt (as of this writing, version JULY-31-2007),
 * or <http://www.sourcemod.net/license.php>.
 *
 * Version: $Id$
 */

#if defined _tf2_included
 #endinput
#endif
#define _tf2_included

#define TF_STUNFLAG_SLOWDOWN        (1 << 0)    /**< activates slowdown modifier */
#define TF_STUNFLAG_BONKSTUCK       (1 << 1)    /**< bonk sound, stuck */
#define TF_STUNFLAG_LIMITMOVEMENT   (1 << 2)    /**< disable forward/backward movement */
#define TF_STUNFLAG_CHEERSOUND      (1 << 3)    /**< cheering sound */
#define TF_STUNFLAG_NOSOUNDOREFFECT (1 << 5)    /**< no sound or particle */
#define TF_STUNFLAG_THIRDPERSON     (1 << 6)    /**< panic animation */
#define TF_STUNFLAG_GHOSTEFFECT     (1 << 7)    /**< ghost particles */
#define TF_STUNFLAG_SOUND           (1 << 8)    /**< sound */

#define TF_STUNFLAGS_LOSERSTATE     TF_STUNFLAG_SLOWDOWN|TF_STUNFLAG_NOSOUNDOREFFECT|TF_STUNFLAG_THIRDPERSON
#define TF_STUNFLAGS_GHOSTSCARE     TF_STUNFLAG_GHOSTEFFECT|TF_STUNFLAG_THIRDPERSON
#define TF_STUNFLAGS_SMALLBONK      TF_STUNFLAG_THIRDPERSON|TF_STUNFLAG_SLOWDOWN
#define TF_STUNFLAGS_NORMALBONK     TF_STUNFLAG_BONKSTUCK
#define TF_STUNFLAGS_BIGBONK        TF_STUNFLAG_CHEERSOUND|TF_STUNFLAG_BONKSTUCK

enum TFClassType
{
	TFClass_Unknown = 0,
	TFClass_Scout,
	TFClass_Sniper,
	TFClass_Soldier,
	TFClass_DemoMan,
	TFClass_Medic,
	TFClass_Heavy,
	TFClass_Pyro,
	TFClass_Spy,
	TFClass_Engineer
};

enum TFTeam
{
	TFTeam_Unassigned = 0,
	TFTeam_Spectator = 1,
	TFTeam_Red = 2,
	TFTeam_Blue = 3
};

enum TFCond
{
	TFCond_Slowed = 0, //0: Revving Minigun, Sniper Rifle. Gives zoomed/revved pose
	TFCond_Zoomed, //1: Sniper Rifle zooming
	TFCond_Disguising, //2: Disguise smoke
	TFCond_Disguised, //3: Disguise
	TFCond_Cloaked, //4: Cloak effect
	TFCond_Ubercharged, //5: Invulnerability, removed when being healed or by another Uber effect
	TFCond_TeleportedGlow, //6: Teleport trail effect
	TFCond_Taunting, //7: Used for taunting, can remove to stop taunting
	TFCond_UberchargeFading, //8: Invulnerability expiration effect
	TFCond_Unknown1, //9
	TFCond_CloakFlicker = 9, //9: Cloak flickering effect
	TFCond_Teleporting, //10: Used for teleporting, does nothing applying
	TFCond_Kritzkrieged, //11: Crit boost, removed when being healed or another Uber effect
	TFCond_Unknown2, //12
	TFCond_TmpDamageBonus = 12, //12: Temporary damage buff, something along with attribute 19
	TFCond_DeadRingered, //13: Dead Ringer damage resistance, gives TFCond_Cloaked
	TFCond_Bonked, //14: Bonk! Atomic Punch effect
	TFCond_Dazed, //15: Slow effect, can remove to remove stun effects
	TFCond_Buffed, //16: Buff Banner mini-crits, icon, and glow
	TFCond_Charging, //17: Forced forward, charge effect
	TFCond_DemoBuff, //18: Eyelander eye glow
	TFCond_CritCola, //19: Mini-crit effect
	TFCond_InHealRadius, //20: Ring effect, rings disappear after a taunt ends
	TFCond_Healing, //21: Used for healing, does nothing applying
	TFCond_OnFire, //22: Ignite sound and vocals, can remove to remove afterburn
	TFCond_Overhealed, //23: Used for overheal, does nothing applying
	TFCond_Jarated, //24: Jarate effect
	TFCond_Bleeding, //25: Bleed effect
	TFCond_DefenseBuffed, //26: Battalion's Backup's defense, icon, and glow
	TFCond_Milked, //27: Mad Milk effect
	TFCond_MegaHeal, //28: Quick-Fix Ubercharge's knockback/stun immunity and visual effect
	TFCond_RegenBuffed, //29: Concheror's speed boost, heal on hit, icon, and glow
	TFCond_MarkedForDeath, //30: Fan o' War marked-for-death effect
	TFCond_NoHealingDamageBuff, //31: Mini-crits, blocks healing, glow, no weapon mini-crit effects
	TFCond_SpeedBuffAlly, //32: Disciplinary Action speed boost
	TFCond_HalloweenCritCandy, //33: Halloween pumpkin crit-boost
	TFCond_CritCanteen, //34: Crit-boost and doubles Sentry Gun fire-rate
	TFCond_CritDemoCharge, //35: Crit glow, adds TFCond_Charging when charge meter is below 75%
	TFCond_CritHype, //36: Soda Popper multi-jump effect
	TFCond_CritOnFirstBlood, //37: Arena first blood crit-boost
	TFCond_CritOnWin, //38: End-of-round crit-boost (May not remove correctly?)
	TFCond_CritOnFlagCapture, //39: Intelligence capture crit-boost
	TFCond_CritOnKill, //40: Crit-boost from crit-on-kill weapons
	TFCond_RestrictToMelee, //41: Prevents switching once melee is out
	TFCond_DefenseBuffNoCritBlock, //42: MvM Bomb Carrier defense buff (TFCond_DefenseBuffed without crit resistance)
	TFCond_Reprogrammed, //43: No longer functions
	TFCond_CritMmmph, //44: Phlogistinator crit-boost
	TFCond_DefenseBuffMmmph, //45: Old Phlogistinator defense buff
	TFCond_FocusBuff, //46: Hitman's Heatmaker no-unscope and faster Sniper charge
	TFCond_DisguiseRemoved, //47: Enforcer damage bonus removed
	TFCond_MarkedForDeathSilent, //48: Marked-for-death without sound effect
	TFCond_DisguisedAsDispenser, //49: Dispenser disguise when crouching, max movement speed, sentries ignore player
	TFCond_Sapped, //50: Sapper sparkle effect in MvM
	TFCond_UberchargedHidden, //51: Out-of-bounds robot invulnerability effect
	TFCond_UberchargedCanteen, //52: Invulnerability effect and Sentry Gun damage resistance
	TFCond_HalloweenBombHead, //53: Bomb head effect (does not explode)
	TFCond_HalloweenThriller, //54: Forced Thriller taunting
	TFCond_RadiusHealOnDamage, //55: Radius healing, adds TFCond_InHealRadius, TFCond_Healing. Removed when a taunt ends, but this condition stays but does nothing
	TFCond_CritOnDamage, //56: Miscellaneous crit-boost
	TFCond_UberchargedOnTakeDamage, //57: Miscellaneous invulnerability
	TFCond_UberBulletResist, //58: Vaccinator Uber bullet resistance
	TFCond_UberBlastResist, //59: Vaccinator Uber blast resistance
	TFCond_UberFireResist, //60: Vaccinator Uber fire resistance
	TFCond_SmallBulletResist, //61: Vaccinator healing bullet resistance
	TFCond_SmallBlastResist, //62: Vaccinator healing blast resistance
	TFCond_SmallFireResist, //63: Vaccinator healing fire resistance
	TFCond_Stealthed, //64: Cloaked until next attack
	TFCond_MedigunDebuff, //65: Unknown
	TFCond_StealthedUserBuffFade, //66: Cloaked, will appear for a few seconds on attack and cloak again
	TFCond_BulletImmune, //67: Full bullet immunity
	TFCond_BlastImmune, //68: Full blast immunity
	TFCond_FireImmune, //69: Full fire immunity
	TFCond_PreventDeath, //70: Survive to 1 health, then the condition is removed
	TFCond_MVMBotRadiowave, //71: Stuns bots and applies radio effect
	TFCond_HalloweenSpeedBoost, //72: Speed boost, non-melee fire rate and reload, infinite air jumps
	TFCond_HalloweenQuickHeal, //73: Healing effect, adds TFCond_Healing along with TFCond_MegaHeal temporarily
	TFCond_HalloweenGiant, //74: Double size, x10 max health increase, ammo regeneration, and forced thirdperson
	TFCond_HalloweenTiny, //75: Half size and increased head size
	TFCond_HalloweenInHell, //76: Applies TFCond_HalloweenGhostMode when the player dies
	TFCond_HalloweenGhostMode, //77: Becomes a ghost unable to attack but can fly
	TFCond_MiniCritOnKill, //78: Mini-crits effect
	TFCond_DodgeChance, //79
	TFCond_ObscuredSmoke = 79, //79: 75% chance to dodge an attack
	TFCond_Parachute, //80: Parachute effect, removed when touching the ground
	TFCond_BlastJumping, //81: Player is blast jumping
	TFCond_HalloweenKart, //82: Player forced into a Halloween kart
	TFCond_HalloweenKartDash, //83: Forced forward if in TFCond_HalloweenKart, zoom in effect, and dash animations
	TFCond_BalloonHead, //84: Big head and lowered gravity
	TFCond_MeleeOnly, //85: Forced melee, along with TFCond_SpeedBuffAlly and TFCond_HalloweenTiny
	TFCond_SwimmingCurse, //86: Swim in the air with Jarate overlay
	TFCond_HalloweenKartNoTurn, //87
	TFCond_FreezeInput = 87, //87: Prevents player from using controls
	TFCond_HalloweenKartCage, //88: Puts a cage around the player if in TFCond_HalloweenKart, otherwise crashes
	TFCond_HasRune, //89: Has a powerup
	TFCond_RuneStrength, //90: Double damage and no damage falloff
	TFCond_RuneHaste, //91: Double fire rate, reload speed, clip and ammo size, and 30% faster movement speed
	TFCond_RuneRegen, //92: Regen ammo, health, and metal
	TFCond_RuneResist, //93: Takes 1/2 damage and critical immunity
	TFCond_RuneVampire, //94: Takes 3/4 damage, gain health on damage, and 40% increase in max health
	TFCond_RuneWarlock, //95: Attacker takes damage and knockback on hitting the player and 50% increase in max health
	TFCond_RunePrecision, //96: Less bullet spread, no damage falloff, 250% faster projectiles, and double damage, faster charge, and faster re-zoom for Sniper Rifles
	TFCond_RuneAgility, //97: Increased movement speed, grappling hook speed, jump height, and instant weapon switch
	TFCond_GrapplingHook, //98: Used when a player fires their grappling hook, no effect applying or removing
	TFCond_GrapplingHookSafeFall, //99: Used when a player is pulled by their grappling hook, no effect applying or removing
	TFCond_GrapplingHookLatched, //100: Used when a player latches onto a wall, no effect applying or removing
	TFCond_GrapplingHookBleeding, //101: Used when a player is hit by attacker's grappling hook
	TFCond_AfterburnImmune, //102: Deadringer afterburn immunity
	TFCond_RuneKnockout, //103: Melee and grappling hook only, increased max health, knockback immunity, x4 more damage against buildings, and knockbacks a powerup off a victim on hit
	TFCond_RuneImbalance, //104: Prevents gaining a crit-boost or Uber powerups
	TFCond_CritRuneTemp, //105: Crit-boost effect
	TFCond_PasstimeInterception, //106: Used when a player intercepts the Jack/Ball
	TFCond_SwimmingNoEffects, //107: Swimming in the air without animations or overlay
	TFCond_EyeaductUnderworld, //108: Refills max health, short Uber, escaped the underworld message on removal
	TFCond_KingRune, //109: Increased max health and applies TFCond_KingAura
	TFCond_PlagueRune, //110: Radius health kit stealing, increased max health, TFCond_Plague on touching a victim
	TFCond_SupernovaRune, //111: Charge meter passively increasing, when charged activiated causes radius Bonk stun
	TFCond_Plague, //112: Plague sound effect and message, blocks King powerup health regen
	TFCond_KingAura, //113: Increased fire rate, reload speed, and health regen to players in a radius
	TFCond_SpawnOutline, //114: Outline and health meter of teammates (and disguised spies)
	TFCond_KnockedIntoAir, //115: Used when a player is airblasted
	TFCond_CompetitiveWinner, //116: Unknown
	TFCond_CompetitiveLoser, //117: Unknown
	TFCond_NoTaunting_DEPRECATED, //118
	TFCond_HealingDebuff = 118, //118: Healing debuff from Medics and dispensers
	TFCond_PasstimePenaltyDebuff, //119: Marked-for-death effect
	TFCond_GrappledToPlayer, //120: Prevents taunting and some Grappling Hook actions
	TFCond_GrappledByPlayer, //121: Unknown
	TFCond_ParachuteDeployed, //122: Parachute deployed, prevents reopening it
	TFCond_Gas, //123: Gas Passer effect
	TFCond_BurningPyro, //124: Dragon's Fury afterburn on Pyros
	TFCond_RocketPack, //125: Thermal Thruster launched effects, prevents reusing
	TFCond_LostFooting, //126: Less ground friction
	TFCond_AirCurrent, //127: Reduced air control and friction
	TFCond_HalloweenHellHeal, // 128: Used when a player gets teleported to hell
	TFCond_PowerupModeDominant, // 129: Reduces effects of certain powerups
	TFCond_ImmuneToPushback // 130: Player is immune to pushback effects
};

const float TFCondDuration_Infinite = -1.0;

enum TFHoliday
{
	TFHoliday_Invalid = -1
};

public const TFHoliday TFHoliday_Birthday;
public const TFHoliday TFHoliday_Halloween;
public const TFHoliday TFHoliday_Christmas;
public const TFHoliday TFHoliday_EndOfTheLine;
public const TFHoliday TFHoliday_CommunityUpdate;
public const TFHoliday TFHoliday_ValentinesDay;
public const TFHoliday TFHoliday_MeetThePyro;
public const TFHoliday TFHoliday_FullMoon;
public const TFHoliday TFHoliday_HalloweenOrFullMoon;
public const TFHoliday TFHoliday_HalloweenOrFullMoonOrValentines;
public const TFHoliday TFHoliday_AprilFools;
public const TFHoliday TFHoliday_Soldier;

enum TFObjectType
{
	TFObject_CartDispenser = 0,
	TFObject_Dispenser = 0,
	TFObject_Teleporter = 1,
	TFObject_Sentry = 2,
	TFObject_Sapper = 3
};

enum TFObjectMode
{
	TFObjectMode_None = 0,
	TFObjectMode_Entrance = 0,
	TFObjectMode_Exit = 1
};

/**
 * Sets a client on fire.
 *
 * @note Fire duration is capped to 10 seconds.
 *
 * @param client        Player's index.
 * @param attacker      Attacker's index.
 * @param duration      Duration of fire (in seconds).
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_IgnitePlayer(int client, int attacker, float duration=10.0);

/**
 * Respawns a client
 *
 * @param client        Player's index.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_RespawnPlayer(int client);

/**
 * Regenerates a client's health and ammunition
 *
 * @param client        Player's index.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_RegeneratePlayer(int client);

/**
 * Adds a condition to a player
 *
 * @param client        Player's index.
 * @param condition     Integer identifier of condition to apply.
 * @param duration      Duration of condition (does not apply to all conditions).
 *                      Pass TFCondDuration_Infinite to apply until manually removed.
 * @param inflictor     Condition inflictor's index (0 for no inflictor).
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_AddCondition(int client, TFCond condition, float duration=TFCondDuration_Infinite, int inflictor=0);

/**
 * Removes a condition from a player
 *
 * @param client        Player's index.
 * @param condition     Integer identifier of condition to remove.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_RemoveCondition(int client, TFCond condition);

/**
 * Enables/disables PowerPlay mode on a player.
 *
 * @param client        Player's index.
 * @param enabled       Whether to enable or disable PowerPlay on player.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_SetPlayerPowerPlay(int client, bool enabled);

/**
 * Disguises a client to the given model and team. Only has an effect on spies.
 *
 * Note: This only starts the disguise process and a delay occurs before the spy is fully disguised
 *
 * @param client        Player's index.
 * @param team          Team to disguise the player as (only TFTeam_Red and TFTeam_Blue have an effect)
 * @param classType     TFClassType class to disguise the player as
 * @param target        Specific target player to disguise as (0 for any)
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_DisguisePlayer(int client, TFTeam team, TFClassType classType, int target=0);

/**
 * Removes the current disguise from a client. Only has an effect on spies.
 *
 * @param client        Player's index.
 * @error               Invalid client index, client not in game, or no mod support.
 */
native void TF2_RemovePlayerDisguise(int client);

/**
 * Stuns a client
 *
 * @param client        Player's index.
 * @param duration      Duration of stun.
 * @param slowdown      Slowdown percent (as decimal, 0.00-1.00)
 *                      Ignored if TF_STUNFLAG_SLOWDOWN is not set.
 * @param stunflags     Stun flags.
 * @param attacker      Attacker's index (0 is allowed for world).
 */
native void TF2_StunPlayer(int client, float duration, float slowdown=0.0, int stunflags, int attacker=0);

/**
 * Induces the bleed effect on a client
 *
 * @param client        Player's index.
 * @param attacker      Attacker's index.
 * @param duration      Duration of bleeding (in seconds).
 */
native void TF2_MakeBleed(int client, int attacker, float duration);

/**
 * Retrieves the entity index of the CPlayerResource entity
 *
 * @return              The current resource entity index.
 * @deprecated          Use GetPlayerResourceEntity instead
 */
#pragma deprecated Use GetPlayerResourceEntity instead
native int TF2_GetResourceEntity();

/**
 * Finds the TFClassType for a given class name.
 *
 * @param classname     A classname string such as "sniper" or "demoman"
 * @return              A TFClassType constant.
 */
native TFClassType TF2_GetClass(const char[] classname);

/**
 * Called on weapon fire to decide if the current shot should be critical.
 * Return Plugin_Continue to let the original calculation or return a higher
 * action to override the decision with the value of 'result'
 *
 * @note Since critical shots are also calculated client side any changes made with
 *       this will not show for the shooter. Projectile weapons such as the rocketlauncher
 *       and demoman weapons will show a critical bullet but no critical sound effect.
 *       Bullet hits should appear as expected.
 *
 * @param client        Client Index.
 * @param weapon        Weapon entity Index.
 * @param weaponname    Classname of the weapon.
 * @param result        Buffer param for the result of the decision.
 */
forward Action TF2_CalcIsAttackCritical(int client, int weapon, char[] weaponname, bool &result);

/**
 * @deprecated          No longer called. Use TF2_OnIsHolidayActive.
 */
#pragma deprecated No longer called. Use TF2_OnIsHolidayActive.
forward Action TF2_OnGetHoliday(TFHoliday &holiday);

/**
 * Called at various times when the game checks to see if the given holiday is active.
 * Return Plugin_Continue to let the original calculation or return a higher
 * action to override the decision with the value of 'result'
 *
 * @param holiday       Holiday being checked.
 * @param result        Buffer param for the result of the decision.
 * @return              Plugin_Continue for original calculation, higher value to use 'result'.
 */
forward Action TF2_OnIsHolidayActive(TFHoliday holiday, bool &result);

/**
 * Returns whether or not a holiday is active
 *
 * @param holiday       Holiday being checked.
 * @return              Boolean of whether or not the holiday is active.
 */
native bool TF2_IsHolidayActive(TFHoliday holiday);

/**
 * Returns whether or not a client (Player) is in a duel.
 *
 * @param client    Client Index.
 * @return              Boolean of whether or not the client/player is dueling.
 */
native bool TF2_IsPlayerInDuel(int client);

/**
 * Removes an econ wearable (hat, misc, etc) from a player.
 * This also deletes the wearable entity.
 *
 * @param client        Client index.
 * @param wearable      Index of the wearable entity.
 * @error               Invalid client index, client not in game, invalid wearable entity, or no mod support.
*/
native void TF2_RemoveWearable(int client, int wearable);

/**
 * Called after a condition is added to a player
 *
 * @param client        Index of the client to which the condition is being added.
 * @param condition     Condition that is being added.
 */
forward void TF2_OnConditionAdded(int client, TFCond condition);

/**
 * Called after a condition is removed from a player
 *
 * @param client        Index of the client to which the condition is being removed.
 * @param condition     Condition that is being removed.
 */
forward void TF2_OnConditionRemoved(int client, TFCond condition);

/**
 * Called when the server enters the Waiting for Players round state
 */
forward void TF2_OnWaitingForPlayersStart();

/**
 * Called when the server exits the Waiting for Players round state
 */
forward void TF2_OnWaitingForPlayersEnd();

/**
 * Called when a player attempts to use a teleporter to decide if the player should be allowed to teleport.
 * Return Plugin_Continue to let the original calculation or return a higher
 * action to override the decision with the value of 'result'
 *
 * @param client        Client index.
 * @param teleporter    Teleporter entity index.
 * @param result        Buffer param for the result of the decision.
 *                      This is prepopulated with the game's original decision to let a player teleport.
 * @return              Plugin_Continue for original calculation, higher value to use 'result'.
 */
forward Action TF2_OnPlayerTeleport(int client, int teleporter, bool &result);
 
/**
 * Do not edit below this line!
 */
public Extension __ext_tf2 = 
{
	name = "TF2 Tools",
	file = "game.tf2.ext",
	autoload = 0,
#if defined REQUIRE_EXTENSIONS
	required = 1,
#else
	required = 0,
#endif
};

#if !defined REQUIRE_EXTENSIONS
public void __ext_tf2_SetNTVOptional()
{
	MarkNativeAsOptional("TF2_IgnitePlayer");
	MarkNativeAsOptional("TF2_RespawnPlayer");
	MarkNativeAsOptional("TF2_RegeneratePlayer");
	MarkNativeAsOptional("TF2_AddCondition");
	MarkNativeAsOptional("TF2_RemoveCondition");
	MarkNativeAsOptional("TF2_SetPlayerPowerPlay");
	MarkNativeAsOptional("TF2_DisguisePlayer");
	MarkNativeAsOptional("TF2_RemovePlayerDisguise");
	MarkNativeAsOptional("TF2_StunPlayer");
	MarkNativeAsOptional("TF2_MakeBleed");
	MarkNativeAsOptional("TF2_GetResourceEntity");
	MarkNativeAsOptional("TF2_GetClass");
	MarkNativeAsOptional("TF2_IsPlayerInDuel");
	MarkNativeAsOptional("TF2_IsHolidayActive");
	MarkNativeAsOptional("TF2_RemoveWearable");
}
#endif

(son includes)

aca tenes un ejemplo de como tenes que poner algunas armas melee:
#include <sourcemod>
#include <tf2_stocks>
#include <tf_econ_data>
#include <tf2items>
#include <clientprefs>
#include <morecolors>
//#define DEBUG

// FIXME = Implementar forma correta de implementar tradução pra essas mensagens.

#pragma semicolon 1
#pragma newdecls optional

#define PLUGIN_VERSION "1.5.6"

public Plugin myinfo = 
{
	name = "[TF2] Conscientious Objector Replacer",
	author = "Peanut",
	description = "Substitui a placa de um player",
	version = PLUGIN_VERSION,
	url = "https://discord.gg/7sRn8Bt"
};

bool g_bReplaceObj[MAXPLAYERS + 1] = { false, ... };
Handle ObjReplacer_cookie;
int rndw[11] = {474, 264, 423, 30758, 1127, 1123, 1071, 1013, 954, 939, 880};


public APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int err_max)
{
	EngineVersion g_engineversion = GetEngineVersion();
	if (g_engineversion != Engine_TF2)
	{
		SetFailState("=======[i see the problem, we're not running TF2 aren't we?]=======");
		return APLRes_Failure;
	}
	return APLRes_Success;
} 

public void OnPluginStart()
{
	CreateConVar("sm_ConObjRep_version", PLUGIN_VERSION, "Rush E", FCVAR_REPLICATED|FCVAR_NOTIFY|FCVAR_DONTRECORD);
	RegAdminCmd("sm_replacenow", Command_replacenow, ADMFLAG_GENERIC, "Substitui a placa de um jogador no momento do comando");
	RegAdminCmd("sm_replacealways", Command_replacealways, ADMFLAG_GENERIC, "Ativa substituição ate a proxíma vez que o jogador se conectar");
	RegAdminCmd("sm_objectorban", Command_ObjectorBan, ADMFLAG_GENERIC, "Bane o jogador de utilizar placas com imagens");
	HookEvent("post_inventory_application", Event_InventoryApplication);
	ObjReplacer_cookie = RegClientCookie("ObjReplacer_cookie", "Should the Plugin Replace objector? 1=yes 0=no", CookieAccess_Protected);
	LoadTranslations("common.phrases");
	LoadTranslations("conobjrep.phrases");
	
	for (int client = 1; client <= MaxClients; client++)
	{
		if (AreClientCookiesCached(client))
			OnClientCookiesCached(client);
	}
}

public void OnClientCookiesCached(int client)
{
	char value[8];
	GetClientCookie(client, ObjReplacer_cookie, value, sizeof(value));

	if (value[0] != '\0')
	{
		g_bReplaceObj[client] = view_as<bool>(StringToInt(value));
	}
	else
	{
		g_bReplaceObj[client] = false;
	}
}

public Action Command_replacenow(int client, int args)
{
	if(args == 0)
	{
		CReplyToCommand(client, "{unique}[O{darkblue}R]{default} %t", "NoTarget");
		return Plugin_Handled;
	}
	char targetArg[MAX_TARGET_LENGTH]; // codigo de adicionar players a uma array
	GetCmdArg(1, targetArg, sizeof(targetArg));

	char targetName[MAX_TARGET_LENGTH];
	int targetList[MAXPLAYERS];
	bool tnIsMl;
	int targetCount = ProcessTargetString(targetArg, client, targetList, MAXPLAYERS,
	COMMAND_FILTER_ALIVE, targetName, sizeof(targetName), tnIsMl);

	if(targetCount <= 0) {
		ReplyToTargetError(client, targetCount);
		return Plugin_Handled;
	}

	for(int i = 0; i < targetCount; i++) { //função q itera entre os players na lista
	int targetClient = targetList[i];
	int rnd = GetRandomInt(0, 10);
	TF2_RemoveWeaponSlot(targetClient, 2);
	if(rndw[rnd] == 1071)
	{
		TF2Items_GiveWeapon(targetClient, "saxxy", 1071, 69, 8, "150 ; 1 ; 542 ; 0");
	}
	else
	{
		TF2Items_GiveWeapon(targetClient, "saxxy", rndw[rnd], 69, 8, "");
	}
	}
	if(tnIsMl) //texto que será exibido no chat
	{
		CPrintToChatAll("{unique}[O{darkblue}R]{default} Arma de %t substituida", targetName); // FIXME
	} 
	else 
	{
		CPrintToChatAll("{unique}[O{darkblue}R]{default} Arma de %s substituida", targetName); // FIXME
	}
	return Plugin_Handled;
}

stock int TF2Items_GiveWeapon(int client, char[] strName, int Index, int Level = 1, int Quality = 0, char[] strAtt = "")
{
	Handle hWeapon = TF2Items_CreateItem(OVERRIDE_ALL | FORCE_GENERATION);

	TFClassType playerClass = TF2_GetPlayerClass(client);
	char itemClass[64];
	TF2Econ_GetItemClassName(Index, itemClass, sizeof(itemClass));

	TF2Econ_TranslateWeaponEntForClass(itemClass, sizeof(itemClass), playerClass);
	TF2Items_SetClassname(hWeapon, itemClass);
	TF2Items_SetItemIndex(hWeapon, Index);
	TF2Items_SetLevel(hWeapon, Level);
	TF2Items_SetQuality(hWeapon, Quality);

	char strAtts[32][32];
	int iCount = ExplodeString(strAtt, " ; ", strAtts, 32, 32);
	
	if(iCount > 1)
	{
		TF2Items_SetNumAttributes(hWeapon, iCount / 2);
		int z;
		for(int i = 0; i < iCount; i += 2)
		{
			TF2Items_SetAttribute(hWeapon, z, StringToInt(strAtts[i]), StringToFloat(strAtts[i + 1]));
			z++;
		}
	}
	else
		TF2Items_SetNumAttributes(hWeapon, 0);

		
	if(hWeapon == INVALID_HANDLE)
		return -1;


	int iEntity = TF2Items_GiveNamedItem(client, hWeapon);

	EquipPlayerWeapon(client, iEntity);
	CloseHandle(hWeapon);
	
	return iEntity;
}

public void OnClientDisconnect(int client)
{
	g_bReplaceObj[client] = false;
}

public Action Command_ObjectorBan(int client, int args)
{
	if(args == 0)
	{
		CReplyToCommand(client, "{unique}[O{darkblue}R]{default} %t", "InvalidTarget");
		return Plugin_Handled;
	}
	char targetArg[MAX_TARGET_LENGTH];
	GetCmdArg(1, targetArg, sizeof(targetArg));

	char targetName[MAX_TARGET_LENGTH];
	int targetList[MAXPLAYERS];
	bool tnIsMl;
	int targetCount = ProcessTargetString(targetArg, client, targetList, MAXPLAYERS,
	COMMAND_FILTER_CONNECTED, targetName, sizeof(targetName), tnIsMl);

	if(targetCount <= 0) 
	{
		ReplyToTargetError(client, targetCount);
		return Plugin_Handled;
	}

	for(int i = 0; i < targetCount; i++) 
	{
		int targetClient = targetList[i];
		g_bReplaceObj[targetClient] = !g_bReplaceObj[targetClient];
		
		if(g_bReplaceObj[targetClient])
		{
			SetClientCookie(targetClient, ObjReplacer_cookie, "1");
		}
		else
		{
			SetClientCookie(targetClient, ObjReplacer_cookie, "0");
		}
		
		if(tnIsMl)
		{
			CPrintToChatAll("{unique}[O{darkblue}R]{default} Banimento de placa alterada para %t", targetName); // FIXME?
		} 
		else 
		{
			CPrintToChatAll("{unique}[O{darkblue}R]{default} Banimento de placa alterada para %s", targetName); // FIXME?
		}
	}
	return Plugin_Handled;
}

public Action Command_replacealways(int client, int args)
{
	if(args == 0)
	{
		CReplyToCommand(client, "{unique}[O{darkblue}R]{default} %t", "InvalidTarget");
		return Plugin_Handled;
	}
	char targetArg[MAX_TARGET_LENGTH]; // codigo de adicionar players a uma array	
	GetCmdArg(1, targetArg, sizeof(targetArg));

	char targetName[MAX_TARGET_LENGTH];
	int targetList[MAXPLAYERS];
	bool tnIsMl;
	int targetCount = ProcessTargetString(targetArg, client, targetList, MAXPLAYERS,
	COMMAND_FILTER_CONNECTED, targetName, sizeof(targetName), tnIsMl);

	if(targetCount <= 0) {
		ReplyToTargetError(client, targetCount);
		return Plugin_Handled;
	}

	for(int i = 0; i < targetCount; i++) { //função q itera entre os players na lista
	int targetClient = targetList[i];
	g_bReplaceObj[targetClient] = !g_bReplaceObj[targetClient];
	/*if(g_bReplaceObj[targetClient])
	{
		if(tnIsMl) //texto que será exibido no chat
		{
			CPrintToChatAll("{unique}[O{darkblue}R]{default} Substituição de placa ativada para %t", targetName);
		} 
		else 
		{
			CPrintToChatAll("{unique}[O{darkblue}R]{default} Substituição de placa ativada para %s", targetName);    
		}
	}
	if(!g_bReplaceObj)
	{
		if(tnIsMl) //texto que será exibido no chat
		{
			CPrintToChatAll("{unique}[O{darkblue}R]{default} Substituição de placa desativada para %t", targetName);
		} 
		else 
		{
			CPrintToChatAll("{unique}[O{darkblue}R]{default} Substituição de placa desativada para %s", targetName);    
		}
	}*/
	}
	if(tnIsMl) //texto que será exibido no chat
		{
			CPrintToChatAll("{unique}[O{darkblue}R]{default} Substituição de placa alterada para %t", targetName); // FIXME
		} 
		else 
		{
			CPrintToChatAll("{unique}[O{darkblue}R]{default} Substituição de placa alterada para %s", targetName); // FIXME
		}
	return Plugin_Handled;
}

public void Event_InventoryApplication(Event event, const char[] name, bool dontBroadcast)
{
	int client = GetClientOfUserId(event.GetInt("userid"));
	if (g_bReplaceObj[client])
    {	
		#if defined DEBUG
		PrintToChatAll("[DEBUG]: Arma deveria ter sido substituida agora");
		#endif
		int weapon = GetPlayerWeaponSlot(client, 2);
		if(IsValidEntity(weapon))	{
			int defindex = GetEntProp(weapon, Prop_Send, "m_iItemDefinitionIndex");
			if(defindex == 474)	{
					int rnd = GetRandomInt(0, 10);
					TF2_RemoveWeaponSlot(client, 2);
					if(rndw[rnd] == 1071)
					{
						TF2Items_GiveWeapon(client, "saxxy", 1071, 69, 8, "150 ; 1 ; 542 ; 0");
					}
					else
					{
						TF2Items_GiveWeapon(client, "saxxy", rndw[rnd], 69, 8, "");
					}
				} 
		}
	}
}

(a lo de objector reemplaze no le des pelota,)
integra lo siguiente tambien:
#pragma semicolon 1

#include <sourcemod>
#include <clientprefs>
#include <tf2_stocks>
#include <tf2attributes>
#include <tf2kstreak>

#pragma newdecls required

#define MAJOR_REVISION "1"
#define MINOR_REVISION "1"
#define PLUGIN_VERSION MAJOR_REVISION..."."...MINOR_REVISION

ConVar cvarEnable;
ConVar cvarHide;
ConVar cvarBots;
ConVar cvarNew;

Handle KCookies;

int BotCounter[MAXPLAYERS+1] = -2;
int BotSheen[MAXPLAYERS+1] = -2;
int BotEffect[MAXPLAYERS+1] = -2;

public Plugin myinfo =
{
	name = "TF2: Killstreak Preferences",
	description = "Allow players to select a killstreak effect",
	author = "Batfoxkid",
	version = PLUGIN_VERSION
}

public APLRes AskPluginLoad2(Handle myself, bool late, char[] error, int err_max)
{
	CreateNative("KStreak_GetCookies", Native_GetCookies);
	CreateNative("KStreak_SetCookies", Native_SetCookies);
	CreateNative("KStreak_Menu", Native_Menu);

	RegPluginLibrary("kstreak_pref");

	return APLRes_Success;
}

public void OnPluginStart()
{
	CreateConVar("kstreak_version", PLUGIN_VERSION, "Version of the plugin", FCVAR_SPONLY|FCVAR_REPLICATED|FCVAR_NOTIFY);
	cvarEnable = CreateConVar("kstreak_enable", "1", "Enable the plugin", _, true, 0.0, true, 1.0);
	cvarHide = CreateConVar("kstreak_hide", "1", "Hide menu items if client doesn't have access to it", _, true, 0.0, true, 1.0);
	cvarBots = CreateConVar("kstreak_bots", "1", "-1-Always None, 0-Random, 1-Always Counter, 2-Always Sheen, 3-Always Killstreaker", _, true, -1.0, true, 3.0);
	cvarNew = CreateConVar("kstreak_new", "1", "Reapply attributes every 300ms (for changing on the spot)", _, true, 0.0, true, 1.0);

	AutoExecConfig(true, "KStreak");

	HookEvent("player_spawn", OnPlayerSpawn, EventHookMode_Pre);
	HookEvent("post_inventory_application", OnInventoryApplication, EventHookMode_Pre);

	RegConsoleCmd("sm_kstreak", MainMenu, "Set my killstreak effects");

	KCookies = RegClientCookie("kstreak_cookies", "Killstreak Preferences", CookieAccess_Protected);

	LoadTranslations("common.phrases");
	LoadTranslations("core.phrases");
	LoadTranslations("kstreak.phrases");
}

public void OnClientPostAdminCheck(int client)
{
	if(AreClientCookiesCached(client))
	{
		char buffer[16];
		GetClientCookie(client, KCookies, buffer, sizeof(buffer));
		if(!buffer[0])
			SetClientCookie(client, KCookies, "-1 -1 -1");
			// Toggle | Sheen | Killstreaker
	}
}

public Action OnPlayerSpawn(Handle event, const char[] name, bool dontBroadcast)
{
	if(!GetConVarBool(cvarEnable))
		return Plugin_Continue;

	int client = GetClientOfUserId(GetEventInt(event, "userid"));
	if(IsValidClient(client))
		CreateTimer(0.3, Timer_CheckClient, client, TIMER_FLAG_NO_MAPCHANGE);

	if(GetConVarInt(cvarBots) >= 0)
	{
		BotCounter[client] = -2;
		BotSheen[client] = -2;
		BotEffect[client] = -2;
	}
	return Plugin_Continue;
}

public Action Timer_CheckClient(Handle timer, int client)
{
	if(!IsValidClient(client) || !GetConVarBool(cvarEnable))
		return Plugin_Continue;

	if(!AreClientCookiesCached(client) && !IsFakeClient(client))
		return Plugin_Continue;

	if(GetConVarBool(cvarNew))
	{
		CreateTimer(0.3, Timer_SetAttributes, client, TIMER_REPEAT|TIMER_FLAG_NO_MAPCHANGE);
	}
	else
	{
		CreateTimer(0.3, Timer_SetAttributes, client, TIMER_FLAG_NO_MAPCHANGE);
	}
	return Plugin_Continue;
}

public Action OnInventoryApplication(Handle event, const char[] name, bool dontBroadcast)
{
	if(!GetConVarBool(cvarEnable))
		return Plugin_Continue;

	CreateTimer(0.3, Timer_CheckClientOnce, GetEventInt(event, "userid"), TIMER_FLAG_NO_MAPCHANGE);
	return Plugin_Continue;
}

public Action Timer_CheckClientOnce(Handle timer, any userid)
{
	int client = GetClientOfUserId(userid);
	if(!IsValidClient(client) || !GetConVarBool(cvarEnable))
		return Plugin_Continue;

	if(AreClientCookiesCached(client) || IsFakeClient(client))
		CreateTimer(0.3, Timer_SetAttributes, client, TIMER_FLAG_NO_MAPCHANGE);

	return Plugin_Continue;
}

public Action Timer_SetAttributes(Handle timer, int client)
{
	if(!IsValidClient(client))
		return Plugin_Stop;

	if(!IsPlayerAlive(client) || (!AreClientCookiesCached(client) && !IsFakeClient(client)) || !GetConVarBool(cvarEnable))
		return Plugin_Stop;

	SetAttributes(client);
	return Plugin_Continue;
}

public void SetAttributes(int client)
{
	if(!IsValidClient(client))	// Check if valid client
		return;

	if(IsFakeClient(client))	// Check if it's a bot
	{
		if(BotCounter[client] < -1)
		{
			if(GetConVarInt(cvarBots)>0 || GetRandomInt(0, 2)>0)
			{
				BotCounter[client] = 1;
			}
			else
			{
				BotCounter[client] = GetRandomInt(-1, 0);
			}
		}
		if(BotSheen[client] < -1)
		{
			if(GetConVarInt(cvarBots)>1 || GetRandomInt(0, 2)>0)
			{
				BotSheen[client] = GetRandomInt(1, 7);
			}
			else
			{
				BotSheen[client] = GetRandomInt(-1, 0);
			}
		}
		if(BotEffect[client] < -1)
		{
			if(GetConVarInt(cvarBots)>2 || GetRandomInt(0, 2)>0)
			{
				BotEffect[client] = GetRandomInt(2002, 2008);
			}
			else
			{
				BotEffect[client] = GetRandomInt(-1, 0);
			}
		}

		int weapon;
		for(int slot; slot<6; slot++)
		{
			weapon=GetPlayerWeaponSlot(client, slot);
			if(IsValidEntity(weapon))
			{
				if(BotCounter[client] == 0)
				{
					TF2Attrib_RemoveByDefIndex(weapon, 2025);
				}

				if(BotSheen[client] == 0)
				{
					TF2Attrib_RemoveByDefIndex(weapon, 2014);
				}

				if(BotEffect[client] == 0)
				{
					TF2Attrib_RemoveByDefIndex(weapon, 2013);
				}

				if(BotCounter[client] > 0)
				{
					TF2Attrib_SetByDefIndex(weapon, 2025, 1.0);

					if(BotSheen[client] != 0)
					{
						if(BotSheen[client] > 0)
						{
							TF2Attrib_SetByDefIndex(weapon, 2014, float(BotSheen[client]));
						}
						if(BotEffect[client] > 0)
						{
							TF2Attrib_SetByDefIndex(weapon, 2013, float(BotEffect[client]));
						}
					}
				}
			}
		}
		return;
	}

	if(!AreClientCookiesCached(client))	// Check if cookies aren't cached
		return;

	char cookies[18];
	char cookieValues[4][5];
	GetClientCookie(client, KCookies, cookies, sizeof(cookies));	// C00KIES
	ExplodeString(cookies, " ", cookieValues, 4, 5);

	int weapon;
	for(int slot; slot<6; slot++)
	{
		weapon=GetPlayerWeaponSlot(client, slot);
		if(IsValidEntity(weapon))
		{
			if(CheckCommandAccess(client, "kstreak_a", 0, true) && StringToInt(cookieValues[0][0])==0)
			{
				TF2Attrib_RemoveByDefIndex(weapon, 2025);
			}

			if(CheckCommandAccess(client, "kstreak_b", 0, true) && StringToInt(cookieValues[1][0])==0)
			{
				TF2Attrib_RemoveByDefIndex(weapon, 2014);
			}

			if(CheckCommandAccess(client, "kstreak_c", 0, true) && StringToInt(cookieValues[2][0])==0)
			{
				TF2Attrib_RemoveByDefIndex(weapon, 2013);
			}

			if(CheckCommandAccess(client, "kstreak_a", 0, true) && StringToInt(cookieValues[0][0])==1)		// Permission and toggled on
			{
				TF2Attrib_SetByDefIndex(weapon, 2025, 1.0);

				if(StringToInt(cookieValues[1][0])!=0)	// Permission and not off
				{
					if(CheckCommandAccess(client, "kstreak_b", 0, true) && StringToInt(cookieValues[1][0]) != -1)	// If not undefined
					{
						TF2Attrib_SetByDefIndex(weapon, 2014, StringToFloat(cookieValues[1][0]));
					}
					if(CheckCommandAccess(client, "kstreak_c", 0, true) && StringToInt(cookieValues[2][0])>0)	// Permission and any on value
					{
						TF2Attrib_SetByDefIndex(weapon, 2013, StringToFloat(cookieValues[2][0]));
					}
				}
			}
		}
	}
}

public Action MainMenu(int client, int args)
{
	if(!client)
	{
		ReplyToCommand(client, "[SM] %t", "Command is in-game only");
		return Plugin_Handled;
	}

	if(!GetConVarBool(cvarEnable) || IsFakeClient(client))
		return Plugin_Handled;

	if(!CheckCommandAccess(client, "_kstreak_a", 0, true))
	{
		ReplyToCommand(client, "[SM] %t", "No Access");
		return Plugin_Handled;
	}

	if(args)
	{
		if(!AreClientCookiesCached(client))
		{
			ReplyToCommand(client, "[SM] %t", "Could not connect to database");
			return Plugin_Handled;
		}

		char cookies[18];
		char cookieValues[4][5];
		GetClientCookie(client, KCookies, cookies, sizeof(cookies));
		ExplodeString(cookies, " ", cookieValues, 4, 5);

		bool changed;
		char argString[64];
		GetCmdArgString(argString, sizeof(argString));

		if(!StrContains(argString, "on", false) || !StrContains(argString, "1", false) || !StrContains(argString, "enab", false) || !StrContains(argString, "yes", false))
		{
			IntToString(1, cookieValues[0], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "cb");
			changed = true;
		}
		else if(!StrContains(argString, "off", false) || !StrContains(argString, "disa", false) || !StrContains(argString, "no", false))
		{
			IntToString(0, cookieValues[0], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "cc");
			changed = true;
		}
		else if(!StrContains(argString, "unde", false) || !StrContains(argString, "-1", false) || !StrContains(argString, "rese", false) || !StrContains(argString, "mayb", false))
		{
			IntToString(-1, cookieValues[0], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "cd");
			changed = true;
		}

		if((!StrContains(argString, "team", false) || !StrContains(argString, "shin", false) || !StrContains(argString, "red", false) || !StrContains(argString, "blu", false)) && CheckCommandAccess(client, "ff2_kstreak_b", 0, true))
		{
			IntToString(1, cookieValues[1], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "ce");
			changed = true;
		}
		else if((!StrContains(argString, "dead", false) || !StrContains(argString, "daff", false) || !StrContains(argString, "yell", false)) && CheckCommandAccess(client, "ff2_kstreak_b", 0, true))
		{
			IntToString(2, cookieValues[1], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "cf");
			changed = true;
		}
		else if((!StrContains(argString, "man", false) || !StrContains(argString, "dari", false) || !StrContains(argString, "oran", false)) && CheckCommandAccess(client, "ff2_kstreak_b", 0, true))
		{
			IntToString(3, cookieValues[1], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "cg");
			changed = true;
		}
		else if((!StrContains(argString, "mean", false) || !StrContains(argString, "gree", false)) && CheckCommandAccess(client, "ff2_kstreak_b", 0, true))
		{
			IntToString(4, cookieValues[1], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "ch");
			changed = true;
		}
		else if((!StrContains(argString, "agon", false) || !StrContains(argString, "emer", false)  || !StrContains(argString, "light", false)) && CheckCommandAccess(client, "ff2_kstreak_b", 0, true))
		{
			IntToString(5, cookieValues[1], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "ci");
			changed = true;
		}
		else if((!StrContains(argString, "vill", false) || !StrContains(argString, "viol", false)  || !StrContains(argString, "pur", false)) && CheckCommandAccess(client, "ff2_kstreak_b", 0, true))
		{
			IntToString(6, cookieValues[1], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "cj");
			if(!changed)
				changed = true;
		}
		else if((!StrContains(argString, "hot", false) || !StrContains(argString, "rod", false)  || !StrContains(argString, "pin", false)) && CheckCommandAccess(client, "ff2_kstreak_b", 0, true))
		{
			IntToString(7, cookieValues[1], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "ck");
			changed = true;
		}

		if((!StrContains(argString, "fire", false) || !StrContains(argString, "horn", false) || !StrContains(argString, "2002", false)) && CheckCommandAccess(client, "ff2_kstreak_c", 0, true))
		{
			IntToString(2002, cookieValues[2], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "cn");
			changed = true;
		}
		else if((!StrContains(argString, "cere", false) || !StrContains(argString, "disc", false) || !StrContains(argString, "2003", false)) && CheckCommandAccess(client, "ff2_kstreak_c", 0, true))
		{
			IntToString(2003, cookieValues[2], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "co");
			changed = true;
		}
		else if((!StrContains(argString, "torn", false) || !StrContains(argString, "2004", false)) && CheckCommandAccess(client, "ff2_kstreak_c", 0, true))
		{
			IntToString(2004, cookieValues[2], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "cp");
			changed = true;
		}
		else if((!StrContains(argString, "flam", false) || !StrContains(argString, "2005", false)) && CheckCommandAccess(client, "ff2_kstreak_c", 0, true))
		{
			IntToString(2005, cookieValues[2], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "cq");
			changed = true;
		}
		else if((!StrContains(argString, "sing", false) || !StrContains(argString, "2006", false)) && CheckCommandAccess(client, "ff2_kstreak_c", 0, true))
		{
			IntToString(2006, cookieValues[2], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "cr");
			changed = true;
		}
		else if((!StrContains(argString, "inci", false) || !StrContains(argString, "2007", false)) && CheckCommandAccess(client, "ff2_kstreak_c", 0, true))
		{
			IntToString(2007, cookieValues[2], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "cs");
			changed = true;
		}
		else if((!StrContains(argString, "hypn", false) || !StrContains(argString, "beam", false) || !StrContains(argString, "2008", false)) && CheckCommandAccess(client, "ff2_kstreak_c", 0, true))
		{
			IntToString(2008, cookieValues[2], sizeof(cookieValues[]));
			ReplyToCommand(client, "[SM] %t", "ct");
			changed = true;
		}

		if(changed)
		{
			Format(cookies, sizeof(cookies), "%s %s %s", cookieValues[0], cookieValues[1], cookieValues[2]);
			SetClientCookie(client, KCookies, cookies);
		}
		else
		{
			ReplyToCommand(client, "[SM] %t", "ca");
		}
		return Plugin_Handled;
	}	

	Handle panel = CreatePanel();
	char text[256];
	SetGlobalTransTarget(client);

	Format(text, sizeof(text), "%t", "ma");	// Killstreak Prefences
	SetPanelTitle(panel, text);

	Format(text, sizeof(text), "%t", "mb");	// Toggle
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "mc");	// Sheens
	if(CheckCommandAccess(client, "kstreak_b", 0, true))
	{
		DrawPanelItem(panel, text);
	}
	else if(!GetConVarBool(cvarHide))
	{
		DrawPanelText(panel, text);
	}

	Format(text, sizeof(text), "%t", "md");	// Killstreakers
	if(CheckCommandAccess(client, "kstreak_c", 0, true))
	{
		DrawPanelItem(panel, text);
	}
	else if(!GetConVarBool(cvarHide))
	{
		DrawPanelText(panel, text);
	}

	Format(text, sizeof(text), "%t", "Exit");
	DrawPanelItem(panel, text);

	SendPanelToClient(panel, client, MainMenuH, MENU_TIME_FOREVER);
	CloseHandle(panel);
	return Plugin_Handled;
}

public int MainMenuH(Handle menu, MenuAction action, int client, int selection)
{
	switch(action)
	{
		case MenuAction_End:
		{
			CloseHandle(menu);
		}
		case MenuAction_Select:
		{
			switch(selection)
			{
				case 1:
				{
					ToggleMenu(client);
				}
				case 2:
				{
					if(CheckCommandAccess(client, "kstreak_b", 0, true))
						SheenMenu(client);
				}
				case 3:
				{
					if(CheckCommandAccess(client, "kstreak_c", 0, true))
						EffectMenu(client);
				}
			}
		}
	}
}

public Action ToggleMenu(int client)
{
	if(!client || !GetConVarBool(cvarEnable) || IsFakeClient(client))
		return Plugin_Handled;

	if(!CheckCommandAccess(client, "kstreak_a", 0, true))
	{
		ReplyToCommand(client, "[SM] %t", "No Access");
		return Plugin_Handled;
	}
	if(!AreClientCookiesCached(client))
	{
		ReplyToCommand(client, "[SM] %t", "Could not connect to database");
		return Plugin_Handled;
	}

	Handle panel = CreatePanel();
	char text[256];
	SetGlobalTransTarget(client);

	Format(text, sizeof(text), "%t", "mb");	// Toggle
	SetPanelTitle(panel, text);

	Format(text, sizeof(text), "%t", "On");
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "Off");
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "ms");	// None
	DrawPanelItem(panel, text);
	
	SendPanelToClient(panel, client, ToggleMenuH, MENU_TIME_FOREVER);
	CloseHandle(panel);
	return Plugin_Handled;
}

public int ToggleMenuH(Handle menu, MenuAction action, int client, int selection)
{
	char cookies[18];
	char cookieValues[4][5];
	GetClientCookie(client, KCookies, cookies, sizeof(cookies));
	ExplodeString(cookies, " ", cookieValues, 4, 5);

	switch(action)
	{
		case MenuAction_End:
		{
			CloseHandle(menu);
		}
		case MenuAction_Select:
		{
			switch(selection)
			{
				case 1:
				{
					ReplyToCommand(client, "[SM] %t", "cb");
					if(StringToInt(cookieValues[0])!=1)
					{
						Format(cookies, sizeof(cookies), "1 %s %s", cookieValues[1], cookieValues[2]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 2:
				{
					ReplyToCommand(client, "[SM] %t", "cc");
					if(StringToInt(cookieValues[0])!=0)
					{
						Format(cookies, sizeof(cookies), "0 %s %s", cookieValues[1], cookieValues[2]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 3:
				{
					ReplyToCommand(client, "[SM] %t", "cd");
					if(StringToInt(cookieValues[0])!=-1)
					{
						Format(cookies, sizeof(cookies), "-1 %s %s", cookieValues[1], cookieValues[2]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
			}
		}
	}
}

public Action SheenMenu(int client)
{
	if(!client || !GetConVarBool(cvarEnable) || IsFakeClient(client))
		return Plugin_Handled;

	if(!CheckCommandAccess(client, "kstreak_b", 0, true))
	{
		ReplyToCommand(client, "[SM] %t", "No Access");
		return Plugin_Handled;
	}
	if(!AreClientCookiesCached(client))
	{
		ReplyToCommand(client, "[SM] %t", "Could not connect to database");
		return Plugin_Handled;
	}

	Handle panel = CreatePanel();
	char text[256];
	SetGlobalTransTarget(client);

	Format(text, sizeof(text), "%t", "mc");	// Sheens
	SetPanelTitle(panel, text);

	Format(text, sizeof(text), "%t", "me");	// Team Shine
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "mf");	// Deadly Daffodil
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "mg");	// Manndarin
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "mh");	// Mean Green
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "mi");	// Agonizing Green
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "mj");	// Villainous Violet
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "mk");	// Hot Rod
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "Off");
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "ms");	// None
	DrawPanelItem(panel, text);
	
	SendPanelToClient(panel, client, SheenMenuH, MENU_TIME_FOREVER);
	CloseHandle(panel);
	return Plugin_Handled;
}

public int SheenMenuH(Handle menu, MenuAction action, int client, int selection)
{
	char cookies[18];
	char cookieValues[4][5];
	GetClientCookie(client, KCookies, cookies, sizeof(cookies));
	ExplodeString(cookies, " ", cookieValues, 4, 5);

	switch(action)
	{
		case MenuAction_End:
		{
			CloseHandle(menu);
		}
		case MenuAction_Select:
		{
			switch(selection)
			{
				case 1:
				{
					ReplyToCommand(client, "[SM] %t", "ce");
					if(StringToInt(cookieValues[1]) != 1)
					{
						Format(cookies, sizeof(cookies), "%s 1 %s", cookieValues[0], cookieValues[2]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 2:
				{
					ReplyToCommand(client, "[SM] %t", "cf");
					if(StringToInt(cookieValues[1]) != 2)
					{
						Format(cookies, sizeof(cookies), "%s 2 %s", cookieValues[0], cookieValues[2]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 3:
				{
					ReplyToCommand(client, "[SM] %t", "cg");
					if(StringToInt(cookieValues[1]) != 3)
					{
						Format(cookies, sizeof(cookies), "%s 3 %s", cookieValues[0], cookieValues[2]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 4:
				{
					ReplyToCommand(client, "[SM] %t", "ch");
					if(StringToInt(cookieValues[1]) != 4)
					{
						Format(cookies, sizeof(cookies), "%s 4 %s", cookieValues[0], cookieValues[2]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 5:
				{
					ReplyToCommand(client, "[SM] %t", "ci");
					if(StringToInt(cookieValues[1]) != 5)
					{
						Format(cookies, sizeof(cookies), "%s 5 %s", cookieValues[0], cookieValues[2]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 6:
				{
					ReplyToCommand(client, "[SM] %t", "cj");
					if(StringToInt(cookieValues[1]) != 6)
					{
						Format(cookies, sizeof(cookies), "%s 6 %s", cookieValues[0], cookieValues[2]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 7:
				{
					ReplyToCommand(client, "[SM] %t", "ck");
					if(StringToInt(cookieValues[1]) != 7)
					{
						Format(cookies, sizeof(cookies), "%s 7 %s", cookieValues[0], cookieValues[2]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 8:
				{
					ReplyToCommand(client, "[SM] %t", "cl");
					if(StringToInt(cookieValues[1]) != 0)
					{
						Format(cookies, sizeof(cookies), "%s 0 %s", cookieValues[0], cookieValues[2]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 9:
				{
					ReplyToCommand(client, "[SM] %t", "cm");
					if(StringToInt(cookieValues[1]) != -1)
					{
						Format(cookies, sizeof(cookies), "%s -1 %s", cookieValues[0], cookieValues[2]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
			}
		}
	}
}

public Action EffectMenu(int client)
{
	if(!client || !GetConVarBool(cvarEnable) || IsFakeClient(client))
		return Plugin_Handled;

	if(!CheckCommandAccess(client, "kstreak_c", 0, true))
	{
		ReplyToCommand(client, "[SM] %t", "No Access");
		return Plugin_Handled;
	}
	if(!AreClientCookiesCached(client))
	{
		ReplyToCommand(client, "[SM] %t", "Could not connect to database");
		return Plugin_Handled;
	}

	Handle panel = CreatePanel();
	char text[256];
	SetGlobalTransTarget(client);

	Format(text, sizeof(text), "%t", "md");	// Killstreakers
	SetPanelTitle(panel, text);

	Format(text, sizeof(text), "%t", "ml");	// Fire Horns
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "mm");	// Cerebral Discharge
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "mn");	// Tornado
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "mo");	// Flames
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "mp");	// Singularity
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "mq");	// Incinerator
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "mr");	// Hypno-Beam
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "Off");
	DrawPanelItem(panel, text);

	Format(text, sizeof(text), "%t", "ms");	// None
	DrawPanelItem(panel, text);
	
	SendPanelToClient(panel, client, EffectMenuH, MENU_TIME_FOREVER);
	CloseHandle(panel);
	return Plugin_Handled;
}

public int EffectMenuH(Handle menu, MenuAction action, int client, int selection)
{
	char cookies[18];
	char cookieValues[4][5];
	GetClientCookie(client, KCookies, cookies, sizeof(cookies));
	ExplodeString(cookies, " ", cookieValues, 4, 5);

	switch(action)
	{
		case MenuAction_End:
		{
			CloseHandle(menu);
		}
		case MenuAction_Select:
		{
			switch(selection)
			{
				case 1:
				{
					ReplyToCommand(client, "[SM] %t", "cn");
					if(StringToInt(cookieValues[2]) != 2002)
					{
						Format(cookies, sizeof(cookies), "%s %s 2002", cookieValues[0], cookieValues[1]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 2:
				{
					ReplyToCommand(client, "[SM] %t", "co");
					if(StringToInt(cookieValues[2]) != 2003)
					{
						Format(cookies, sizeof(cookies), "%s %s 2003", cookieValues[0], cookieValues[1]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 3:
				{
					ReplyToCommand(client, "[SM] %t", "cp");
					if(StringToInt(cookieValues[2]) != 2004)
					{
						Format(cookies, sizeof(cookies), "%s %s 2004", cookieValues[0], cookieValues[1]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 4:
				{
					ReplyToCommand(client, "[SM] %t", "cq");
					if(StringToInt(cookieValues[2]) != 2005)
					{
						Format(cookies, sizeof(cookies), "%s %s 2005", cookieValues[0], cookieValues[1]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 5:
				{
					ReplyToCommand(client, "[SM] %t", "cr");
					if(StringToInt(cookieValues[2]) != 2006)
					{
						Format(cookies, sizeof(cookies), "%s %s 2006", cookieValues[0], cookieValues[1]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 6:
				{
					ReplyToCommand(client, "[SM] %t", "cs");
					if(StringToInt(cookieValues[2]) != 2007)
					{
						Format(cookies, sizeof(cookies), "%s %s 2007", cookieValues[0], cookieValues[1]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 7:
				{
					ReplyToCommand(client, "[SM] %t", "ct");
					if(StringToInt(cookieValues[2]) != 2008)
					{
						Format(cookies, sizeof(cookies), "%s %s 2008", cookieValues[0], cookieValues[1]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 8:
				{
					ReplyToCommand(client, "[SM] %t", "cu");
					if(StringToInt(cookieValues[2]) != 0)
					{
						Format(cookies, sizeof(cookies), "%s %s 0", cookieValues[0], cookieValues[1]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
				case 9:
				{
					ReplyToCommand(client, "[SM] %t", "cv");
					if(StringToInt(cookieValues[2]) != -1)
					{
						Format(cookies, sizeof(cookies), "%s %s -1", cookieValues[0], cookieValues[1]);
						SetClientCookie(client, KCookies, cookies);
					}
				}
			}
		}
	}
}

stock bool IsValidClient(int client)
{
	if(client<=0 || client>MaxClients)
		return false;

	if(!IsClientInGame(client))
		return false;

	if(GetEntProp(client, Prop_Send, "m_bIsCoaching"))
		return false;

	if(IsClientSourceTV(client) || IsClientReplay(client))
		return false;

	return true;
}

public int Native_GetCookies(Handle plugin, int numParams)
{
	if(GetNativeCell(2)>2 || GetNativeCell(2)<0)
		return -2;

	int client = GetNativeCell(1);
	if(IsValidClient(client) && AreClientCookiesCached(client) && !IsFakeClient(client))
	{
		char cookies[18];
		char cookieValues[4][5];
		GetClientCookie(client, KCookies, cookies, sizeof(cookies));
		ExplodeString(cookies, " ", cookieValues, 4, 5);
		return StringToInt(cookieValues[GetNativeCell(2)]);
	}
	return -2;
}

public int Native_SetCookies(Handle plugin, int numParams)
{
	int client = GetNativeCell(1);
	if(IsValidClient(client) && AreClientCookiesCached(client) && !IsFakeClient(client))
	{
		char cookies[18];
		char cookieValues[4][5];
		GetClientCookie(client, KCookies, cookies, sizeof(cookies));
		ExplodeString(cookies, " ", cookieValues, 4, 5);
		bool changed;

		if(GetNativeCell(2)>-2 && GetNativeCell(2)<2)
		{
			IntToString(GetNativeCell(2), cookieValues[0][0], sizeof(cookieValues[]));
			if(!changed)
				changed = true;
		}
		if(GetNativeCell(3)>-2 && GetNativeCell(3)<8)
		{
			IntToString(GetNativeCell(3), cookieValues[1][0], sizeof(cookieValues[]));
			if(!changed)
				changed = true;
		}
		if((GetNativeCell(4)>-2 && GetNativeCell(4)<1) || (GetNativeCell(4)>2001 && GetNativeCell(2)<2009))
		{
			IntToString(GetNativeCell(4), cookieValues[2][0], sizeof(cookieValues[]));
			if(!changed)
				changed = true;
		}

		if(changed)
		{
			Format(cookies, sizeof(cookies), "%s %s %s", cookieValues[0], cookieValues[1], cookieValues[2]);
			SetClientCookie(client, KCookies, cookies);
			return true;
		}
	}
	return false;
}

public int Native_Menu(Handle plugin, int numParams)
{
	int client = GetNativeCell(1);
	switch(GetNativeCell(2))
	{
		case 0:
			MainMenu(client, 0);
		case 1:
			ToggleMenu(client);
		case 2:
			SheenMenu(client);
		case 3:
			EffectMenu(client);
	}
}

#file "TF2: Killstreak Preferences"



warpaints:
/* Definitions
==================================================================================================== */

#pragma semicolon 1
#include <sourcemod>
#include <tf2items>
#pragma newdecls required

public const int allowedWeps[45] = { 
	37, 172, 194, 197, 199, 200, 201, 202, 
	203, 205, 206, 207, 208, 209, 210, 211,
	214, 215, 220, 221, 228, 304, 305, 308,
	312, 326, 327, 329, 351, 401, 402, 404, 
	415, 424, 425, 447, 448, 449, 740, 996, 
	997, 1104, 1151, 1153, 1178 };

int g_iMySkin[MAXPLAYERS + 1];
ConVar g_cvWear;

public Plugin myinfo =
{
	name = "[TF2] Warpaint Skins",
	author = "StrikeR14",
	description = "Apply warpaint skins!",
	version = "1.1.1",
	url = "https://steamcommunity.com/id/kenmaskimmeod/"
};

public void OnPluginStart()
{
	RegConsoleCmd("sm_skin", SetSkin);
	RegConsoleCmd("sm_setskin", SetSkin);

	g_cvWear = CreateConVar("sm_warpaint_wear", "0.0", "Skin wear value", _, true, 0.0, true, 1.0); 
}

public void OnClientPutInServer(int client)
{
	g_iMySkin[client] = 0;
}

public Action SetSkin(int client, int args)
{
	if(!client)
	{
		return Plugin_Handled;
	}

	if(args != 1)
	{
		ReplyToCommand(client, "[SM] Usage: sm_setskin <id>");
		return Plugin_Handled;
	}

	char arg[8];
	GetCmdArg(1, arg, sizeof(arg));
	int skin = StringToInt(arg);

	if(!skin)
	{
		g_iMySkin[client] = 0;
		ReplyToCommand(client, "[SM] Successfully deleted skin.");
		return Plugin_Handled;
	}

	if(!IsValidWarpaint(skin))
	{
		PrintToChat(client, "[SM] Unavailable skin id (%i).", skin);
		PrintToChat(client, "[SM] Available values: 102, 104-106, 109, 112-114, 112, 130, 139, 143, 144, 151, 160, 161, 163,");
		PrintToChat(client, "[SM] Available values: 200-215, 217, 218, 220, 221, 223-226, 228, 230, 232, 234-273, 300-310.");
		return Plugin_Handled;
	}

	g_iMySkin[client] = StringToInt(arg);
	PrintToChat(client, "[SM] Successfully applied skin. Respawn to apply it.");
	return Plugin_Handled;
}

public Action TF2Items_OnGiveNamedItem(int client, char[] classname, int iItemDefinitionIndex, Handle &hItem)
{
	if(!g_iMySkin[client] || !FindInDef(iItemDefinitionIndex))
	{
		return Plugin_Continue;
	}

	hItem = TF2Items_CreateItem(OVERRIDE_ATTRIBUTES | PRESERVE_ATTRIBUTES);
	TF2Items_SetNumAttributes(hItem, 2);
	TF2Items_SetAttribute(hItem, 0, 834, view_as<float>(g_iMySkin[client]));
	TF2Items_SetAttribute(hItem, 1, 725, g_cvWear.FloatValue);	 // Factory new, minimal wear...
	TF2Items_SetFlags(hItem, OVERRIDE_ATTRIBUTES | PRESERVE_ATTRIBUTES);
	return Plugin_Changed;
}

bool FindInDef(const int def)
{
	for(int i = 0; i < sizeof(allowedWeps); i++)
	{
		if(allowedWeps[i] == def)
			return true;
	}

	return false;
}

bool IsValidWarpaint(const int war)
{
	return (102 <= war <= 114 && war != 103 && war != 107 && war != 108 && war != 110 && war != 111) 
	|| war == 122 || war == 130 || war == 139 || war == 143 || war == 144 || war == 151 || war == 160 || war == 161 || war == 163
	|| (200 <= war <= 283 && war != 216 && war != 219 && war != 222 && war != 227 && war != 229 && war != 231 && war != 233 && war != 274)
	|| (300 <= war <= 310);
}


(y actualizalo con las nuevas tambien si podes, )

Australium:
#include <sourcemod>
#pragma semicolon 1
#include <tf2items>
#include <tf2_stocks>
#include <clientprefs>

bool hasAustralium[MAXPLAYERS+1];
Handle cHasAustralium;

#define PLUGIN_VERSION "1.0"
#define AUS_ATTRS "2027 ; 1 ; 2022 ; 1 ; 542 ; 1"
#define AUS_ATTRS_NEG "1 ; 0.0"

public Plugin myinfo = {
	name		= "[TF2] Australium Weapons",
	author		= "Nanochip",
	description = "Give yourself australium weapons!",
	version		= PLUGIN_VERSION,
	url			= "https://forums.alliedmods.net/showthread.php?p=2445005"
};

public void OnPluginStart()
{
	CreateConVar("sm_australium_version", PLUGIN_VERSION, "Australium Version", FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_UNLOGGED|FCVAR_DONTRECORD|FCVAR_REPLICATED|FCVAR_NOTIFY);
	RegConsoleCmd("sm_australium", Cmd_Australium);
	
	HookEvent("post_inventory_application", OnResupply);
	
	cHasAustralium = RegClientCookie("sm_australium_cookie", "", CookieAccess_Private);
	
	for (new i = 1; i <= MaxClients; i++)
	{
		hasAustralium[i] = false;
		if(IsClientInGame(i) && AreClientCookiesCached(i)) OnClientCookiesCached(i);
	}
}

public Action OnResupply(Handle event, char[] name, bool dontBroadcast)
{
	CreateTimer(0.1, remwep);
}

public void OnClientAuthorized(client, const char[] auth)
{
	hasAustralium[client] = false;
}

public OnClientCookiesCached(client)
{
	char value[11];
	GetClientCookie(client, cHasAustralium, value, sizeof(value));
	if (StrEqual(value, "true"))
	{
		if (CheckCommandAccess(client, "sm_australium", 0, false))
		{
			hasAustralium[client] = true;
		}
		else
		{
			SetClientCookie(client, cHasAustralium, "false");
		}
	}
}

public void OnGameFrame()
{
	for (int client = 1; client <= MaxClients; client++)
	{
		if (!IsClientInGame(client) || !IsPlayerAlive(client)) return;
		
		if (!hasAustralium[client])
		{
			if (IsAustralium(client, 0))
			{
				int ammo = GetAmmo(client, 0);
				int clip = GetClip(client, 0);
				switch (GetIndexOfWeaponSlot(client, 0))
				{
					case 200:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_scattergun", 13, 69, 6, "", "stock");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 45:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_scattergun", 45, 69, 6, "44 ; 1 ; 6 ; 0.5 ; 45 ; 1.2 ; 1 ; 0.9 ; 3 ; 0.34 ; 43 ; 1 ; 328 ; 1", "stock", false);
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 205:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_rocketlauncher", 18, 69, 6, "", "stock");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 228:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_rocketlauncher", 228, 69, 6, "741 ; 20 ; 3 ; 0.75 ; 328 ; 1", "stock");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 208:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_flamethrower", 21, 69, 6, "", "stock");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 206:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_grenadelauncher", 19, 69, 6, "", "stock");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 202:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_minigun", 15, 69, 6, "", "stock");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 424:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_minigun", 424, 69, 6, "87 ; 0.8 ; 238 ; 1 ; 5 ; 1.2 ; 106 ; 0.8", "stock", false);
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 141:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_sentry_revenge", 141, 69, 6, "136 ; 1 ; 15 ; 0 ; 3 ; 0.5 ; 551 ; 1", "stock", false);
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 36:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_syringegun_medic", 36, 69, 6, "16 ; 3 ; 129 ; -2", "stock", false);
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 201:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_sniperrifle", 14, 69, 6, "", "stock");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 61:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_revolver", 61, 69, 6, "51 ; 1 ; 1 ; 0.85 ; 5 ; 1.2 ; 15 ; 0", "stock", false);
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
				}
			}
			
			if (IsAustralium(client, 1))
			{
				int ammo = GetAmmo(client, 1);
				int clip = GetClip(client, 1);
				switch (GetIndexOfWeaponSlot(client, 1))
				{
					case 203:
					{
						TF2_RemoveWeaponSlot(client, 1);
						SpawnWeapon(client, "tf_weapon_smg", 16, 69, 6, "", "stock");
						SetAmmo(client, ammo, 1);
						SetClip(client, clip, 1);
					}
					case 211:
					{
						TF2_RemoveWeaponSlot(client, 1);
						SpawnWeapon(client, "tf_weapon_medigun", 29, 69, 6, "", "stock");
					}
					case 207:
					{
						TF2_RemoveWeaponSlot(client, 1);
						SpawnWeapon(client, "tf_weapon_pipebomblauncher", 20, 69, 6, "", "stock");
						SetAmmo(client, ammo, 1);
						SetClip(client, clip, 1);
					}
				}
			}
			
			if (IsAustralium(client, 2))
			{
				switch (GetIndexOfWeaponSlot(client, 2))
				{
					case 38:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_fireaxe", 38, 69, 6, "209 ; 1 ; 1 ; 0.67 ; 15 ; 0 ; 773 ; 1.75 ; 5 ; 1.2", "stock", false);
					}
					case 194:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_knife", 4, 69, 6, "", "stock");
					}
					case 197:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_wrench", 7, 69, 6, "", "stock");
					}
					case 132:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_sword", 132, 69, 6, "781 ; 1 ; 15 ; 0 ; 125 ; -25 ; 219 ; 1 ; 292 ; 6 ; 388 ; 6 ; 551 ; 1", "stock", false);
					}
					case 1071:
					{
						TF2_RemoveWeaponSlot(client, 2);
						switch(TF2_GetPlayerClass(client))
						{
							case TFClass_Scout:		SpawnWeapon(client, "tf_weapon_bat", 0, 69, 6, "", "stock");
							case TFClass_Soldier:	SpawnWeapon(client, "tf_weapon_shovel", 6, 69, 6, "", "stock");
							case TFClass_Pyro:		SpawnWeapon(client, "tf_weapon_fireaxe", 2, 69, 6, "", "stock");
							case TFClass_DemoMan:	SpawnWeapon(client, "tf_weapon_bottle", 1, 69, 6, "", "stock");
							case TFClass_Heavy:		SpawnWeapon(client, "tf_weapon_fists", 5, 69, 6, "", "stock");
							case TFClass_Medic:		SpawnWeapon(client, "tf_weapon_bonesaw", 8, 69, 6, "", "stock");
							case TFClass_Sniper:	SpawnWeapon(client, "tf_weapon_club", 3, 69, 6, "", "stock");
						}
					}
				}
			}
		}
		
		else
		{
			if (!IsAustralium(client, 0))
			{
				int ammo = GetAmmo(client, 0);
				int clip = GetClip(client, 0);
				switch (GetIndexOfWeaponSlot(client, 0))
				{
					case 13:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_scattergun", 200, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 45:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_scattergun", 45, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 18:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_rocketlauncher", 205, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 228:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_rocketlauncher", 228, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 21:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_flamethrower", 208, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 19:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_grenadelauncher", 206, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 15:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_minigun", 202, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 424:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_minigun", 424, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 141:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_sentry_revenge", 141, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 36:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_syringegun_medic", 36, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 14:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_sniperrifle", 201, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
					case 61:
					{
						TF2_RemoveWeaponSlot(client, 0);
						SpawnWeapon(client, "tf_weapon_revolver", 61, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 0);
						SetClip(client, clip, 0);
					}
				}
			}
			
			if (!IsAustralium(client, 1))
			{
				int ammo = GetAmmo(client, 1);
				int clip = GetClip(client, 1);
				switch (GetIndexOfWeaponSlot(client, 1))
				{
					case 16:
					{
						TF2_RemoveWeaponSlot(client, 1);
						SpawnWeapon(client, "tf_weapon_smg", 203, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 1);
						SetClip(client, clip, 1);
					}
					case 29:
					{
						TF2_RemoveWeaponSlot(client, 1);
						SpawnWeapon(client, "tf_weapon_medigun", 211, 69, 6, AUS_ATTRS, "nano_australium");
					}
					case 20:
					{
						TF2_RemoveWeaponSlot(client, 1);
						SpawnWeapon(client, "tf_weapon_pipebomblauncher", 207, 69, 6, AUS_ATTRS, "nano_australium");
						SetAmmo(client, ammo, 1);
						SetClip(client, clip, 1);
					}
				}
			}
			
			if (!IsAustralium(client, 2))
			{
				switch (GetIndexOfWeaponSlot(client, 2))
				{
					case 38:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_fireaxe", 38, 69, 6, AUS_ATTRS, "nano_australium");
					}
					case 4:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_knife", 194, 69, 6, AUS_ATTRS, "nano_australium");
					}
					case 7:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_wrench", 197, 69, 6, AUS_ATTRS, "nano_australium");
					}
					case 132:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_sword", 132, 69, 6, AUS_ATTRS, "nano_australium");
					}
					case 0:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_bat", 1071, 69, 6, "150 ; 1 ; 542 ; 0", "nano_australium");
					}
					case 6:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_shovel", 1071, 69, 6, "150 ; 1 ; 542 ; 0", "nano_australium");
					}
					case 2:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_fireaxe", 1071, 69, 6, "150 ; 1 ; 542 ; 0", "nano_australium");
					}
					case 1:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_bottle", 1071, 69, 6, "150 ; 1 ; 542 ; 0", "nano_australium");
					}
					case 5:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_fists", 1071, 69, 6, "150 ; 1 ; 542 ; 0", "nano_australium");
					}
					case 8:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_bonesaw", 1071, 69, 6, "150 ; 1 ; 542 ; 0", "nano_australium");
					}
					case 3:
					{
						TF2_RemoveWeaponSlot(client, 2);
						SpawnWeapon(client, "tf_weapon_club", 1071, 69, 6, "150 ; 1 ; 542 ; 0", "nano_australium");
					}
				}
			}
		}
	}
}

bool IsAustralium(int client, int slot)
{
	char strName[32];
	int weaponEnt = GetPlayerWeaponSlot(client, slot);
	if (!IsValidEdict(weaponEnt)) return false;
	GetEntPropString(weaponEnt, Prop_Data, "m_iName", strName, sizeof(strName));
	return StrEqual(strName, "nano_australium");
}

public Action Cmd_Australium(int client, int args)
{
	if (!hasAustralium[client])
	{
		hasAustralium[client] = true;
		SetClientCookie(client, cHasAustralium, "true");
		ReplyToCommand(client, "[SM] Enabled Australium Weapons.");
	}
	else
	{
		hasAustralium[client] = false;
		SetClientCookie(client, cHasAustralium, "false");
		ReplyToCommand(client, "[SM] Disabled Australium Weapons.");
	}
	return Plugin_Handled;
}

stock int GetClip(int client, int slot)
{
	int weapon = GetPlayerWeaponSlot(client, slot);
	int iAmmoTable = FindSendPropInfo("CTFWeaponBase", "m_iClip1");
	return GetEntData(weapon, iAmmoTable);
}

stock void SetClip(int client, int ammo, int slot)
{
	int weapon = GetPlayerWeaponSlot(client, slot);
	int iAmmoTable = FindSendPropInfo("CTFWeaponBase", "m_iClip1");
	SetEntData(weapon, iAmmoTable, ammo, 4, true);
}

stock int GetAmmo(int client, int slot)
{
	int weapon = GetPlayerWeaponSlot(client, slot);
	int iOffset = GetEntProp(weapon, Prop_Send, "m_iPrimaryAmmoType", 1)*4;
	int iAmmoTable = FindSendPropInfo("CTFPlayer", "m_iAmmo");
	return GetEntData(client, iOffset + iAmmoTable);
}

stock void SetAmmo(int client, int ammo, int slot)
{
	int weapon = GetPlayerWeaponSlot(client, slot);
	int iOffset = GetEntProp(weapon, Prop_Send, "m_iPrimaryAmmoType", 1)*4;
	int iAmmoTable = FindSendPropInfo("CTFPlayer", "m_iAmmo");
	SetEntData(client, iAmmoTable+iOffset, ammo, 4, true);
}

stock SpawnWeapon(client, String:name[], index, level, qual, String:att[], String:targetname[], bool:preserve = true)
{
	int flags = OVERRIDE_ALL|FORCE_GENERATION;
	if (preserve)
	{
		flags |= PRESERVE_ATTRIBUTES;
	}
	new Handle:hWeapon=TF2Items_CreateItem(flags);
	if(hWeapon==INVALID_HANDLE)
	{
		return -1;
	}

	TF2Items_SetClassname(hWeapon, name);
	TF2Items_SetItemIndex(hWeapon, index);
	TF2Items_SetLevel(hWeapon, level);
	TF2Items_SetQuality(hWeapon, qual);
	new String:atts[32][32];
	new count=ExplodeString(att, ";", atts, 32, 32);

	if(count % 2)
	{
		--count;
	}

	if(count>0)
	{
		TF2Items_SetNumAttributes(hWeapon, count/2);
		new i2;
		for(new i; i<count; i+=2)
		{
			new attrib=StringToInt(atts[i]);
			if(!attrib)
			{
				LogError("Bad weapon attribute passed: %s ; %s", atts[i], atts[i+1]);
				CloseHandle(hWeapon);
				return -1;
			}

			TF2Items_SetAttribute(hWeapon, i2, attrib, StringToFloat(atts[i+1]));
			i2++;
		}
	}
	else
	{
		TF2Items_SetNumAttributes(hWeapon, 0);
	}

	new entity=TF2Items_GiveNamedItem(client, hWeapon);
	DispatchKeyValue(entity, "targetname", targetname);
	CloseHandle(hWeapon);
	EquipPlayerWeapon(client, entity);
	return entity;
}

stock int GetIndexOfWeaponSlot(int client, int slot)
{
    return GetWeaponIndex(GetPlayerWeaponSlot(client, slot));
}
 
stock int GetWeaponIndex(int weapon)
{
    return IsValidEnt(weapon) ? GetEntProp(weapon, Prop_Send, "m_iItemDefinitionIndex"):-1;
}
 
stock bool IsValidEnt(int ent)
{
    return ent > MaxClients && IsValidEntity(ent);
}

public Action remwep(Handle timer)
{
	int ent = FindEntityByClassname(-1, "tf_dropped_weapon");
	while (ent != -1)
	{
		RemoveEdict(ent);
		ent = FindEntityByClassname(-1, "tf_dropped_weapon");
	}
}

y agrega los efectos inusuales para las armas y elejir su ""calidad"" y spells, pero no modifiques los atributos de las armas, porque el tf2atributtes y demas esta para modificar su calidad,spells, warpaints y inusuales,
